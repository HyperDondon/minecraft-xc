/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TUPLE SIZES `A, B, C, ...`. DO NOT EDIT THIS
 * FILE DIRECTLY.
 * 
 * Contains hard-coded generics component tuples and iterators
 * for iterating over a set of distinct component types.
 * This avoids runtime type casting for different component tuple
 * sizes in system function component iterator queries:
 * 
 * Without hard-coded generics, if we wanted a general function that
 * could iterate over a set of components defined by a vararg of enums,
 * 
 *      for (a, b, c) in components.query(Type.A, Type.B, Type.C) {
 *         // ...                     ^
 *      }                             |
 *                                    |
 *                       Must return different iterator types
 *                       for (a,), (a, b), (a, b, c), ...
 *                       How can same function have different
 *                       return types?
 * 
 * This is a limitation of Kotlin/Java type system. Even if it worked, it
 * would require some forms of runtime type casting.
 * 
 * Instead, hard-code each generic `ComponentTupleN` for N components.
 * The iterator now looks like:
 * 
 *      for (a, b, c) in ComponentTuple3<A, B, C>.query(components) {
 *         // ...
 *      }
 * 
 * This is more annoying since we have to type the specific "N" size,
 * but this allows us to avoid any runtime type casting and now allows
 * iterating different component tuple sizes.
 */

package phonon.xv.core

import java.util.EnumSet


/**
 * TODO: do we even need?
 */
interface ComponentTuple {
    
}

{% for v in tuple_implementations %}
{{ v }}
{% endfor %}