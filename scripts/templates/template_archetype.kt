/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Archetype style ECS data storage core.
 * 
 * Contains vehicle component enum + interface and archetype storage.
 * 
 * Since component set is finite, just hard-code optional component
 * storages in each archetype. Engine must ensure we only access
 * valid storages in the archetype
 * 
 * See references:
 * https://github.com/amethyst/legion/blob/master/src/internals/storage/archetype.rs
 */

package phonon.xv.core

import java.util.EnumSet
import phonon.xv.core.INVALID_ELEMENT_ID
import phonon.xv.component.*
import java.util.Stack

public const val INVALID_DENSE_INDEX: Int = -1

/**
 * Note: keep in alphabetical order.
 */
public enum class VehicleComponentType {
    {%- for c in components %}
    {{ c.enum }},
    {%- endfor %}
    ;

    public companion object {
        /**
         * Converts from compile-time generic vehicle component type. 
         */
        public inline fun <reified T: VehicleComponent> from(): VehicleComponentType {
            return when ( T::class ) {
                {%- for c in components %}
                {{ c.classname }}::class -> VehicleComponentType.{{ c.enum }}
                {%- endfor %}
                else -> throw Exception("Unknown component type")
            }
        }
    }
}

/**
 * Component interface
 */
public interface VehicleComponent {
    // Vehicle component type enum.
    val type: VehicleComponentType
}

/**
 * Archetype, contains set of possible component storages.
 * Components stored in packed struct-of-arrays format.
 * Element Id used to lookup packed index.
 */
public class ArchetypeStorage(
    val layout: EnumSet<VehicleComponentType>,
    val maxElements: Int,
) {
    public var size: Int = 0
        // private set // TODO: when implemented, outside should never change size

    // fluffy start, vehicle element id manager + dense map/array

    // element id => element
    private val lookup: Array<VehicleElement?> = Array(maxElements, { _ -> null })
    // stack of free ids that are not at the end of the lookup array
    private val freeIds: Stack<Int> = Stack()
    // lookup array vehicle element id => dense array index
    // the sets we're mapping have equal cardinality, we use a dense map
    // to keep all components in contiguous block in dense array
    private val denseLookup: Array<Int> = Array(maxElements, { _ -> INVALID_DENSE_INDEX })
    // dense array index => vehicle element id
    // only internal cuz iterator classes need it
    internal val elements: IntArray = IntArray(maxElements, { _ -> INVALID_ELEMENT_ID })
    // dense array implicit linked list head

    // element id => element lookup, function for type safety
    public fun lookup(id: VehicleElementId): VehicleElement? {
        return lookup[id]
    }

    // reserves a new element id and internally adds an entry in dense array
    public fun newId(): VehicleElementId {
        // no freeIds between index 0 and size
        val newId = if ( freeIds.isEmpty() ) {
            // we're at max capacity, just return invalid
            if ( size >= MAX_VEHICLE_ELEMENTS ) {
                return INVALID_VEHICLE_ID
            } else { // otherwise just use size as index
                size++
            }
        } else {
            size++
            freeIds.pop()
        }


        return newId
    }

    public fun freeId(id: VehicleElementId) {

    }

    // fluffy end

    /*
    // map from vehicle element id => element's dense array index
    // TODO: replace with specialized Densemap
    public val lookup: HashMap<VehicleElementId, Int> = HashMap()

    // dense packed element ids
    public val elements: IntArray = IntArray(maxElements, {_ -> INVALID_ELEMENT_ID})
    */

    // dense packed components
    // only components in layout will be non-null
    {%- for c in components %}
    public val {{ c.storage }}: ArrayList<{{ c.classname }}>? = if ( layout.contains(VehicleComponentType.{{ c.enum }}) ) ArrayList() else null
    {%- endfor %}
    
    /**
     * Remove all elements from archetype.
     */
    public fun clear() {
        size = 0
        lookup.clear()

        {%- for c in components %}
        {{ c.storage }}?.clear()
        {%- endfor %}
    }

    public companion object {
        /**
         * Higher order function that returns a function that gets a
         * Vehicle component type's storage within the archetype.
         * Needed to allows compile-time access to a type's component
         * storage in the archetype. Used for generic tuple iterators.
         * 
         * Internally does unsafe cast, since storages may be null.
         * Client caller must make sure archetypes have the storages.
         * 
         * Note: this may be generating a new lambda object at each call.
         * May want to cache the lambda object, or hard-code each function
         * in future.
         */
        @Suppress("UNCHECKED_CAST")
        public inline fun <reified T> accessor(): (ArchetypeStorage) -> ArrayList<T> {
            return when ( T::class ) {
                {%- for c in components %}
                {{ c.classname }}::class -> { archetype -> archetype.{{ c.storage }} as ArrayList<T> }
                {%- endfor %}
                else -> throw Exception("Unknown component type")
            }
        }
    }
}
