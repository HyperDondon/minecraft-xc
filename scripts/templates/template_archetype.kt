/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Archetype style ECS data storage core.
 * 
 * Contains vehicle component enum + interface and archetype storage.
 * 
 * Since component set is finite, just hard-code optional component
 * storages in each archetype. Engine must ensure we only access
 * valid storages in the archetype
 * 
 * See references:
 * https://github.com/amethyst/legion/blob/master/src/internals/storage/archetype.rs
 */

package phonon.xv.core

import java.util.EnumSet
import phonon.xv.core.INVALID_ID
import phonon.xv.component.*


/**
 * Note: keep in alphabetical order.
 */
public enum class VehicleComponentType {
    {%- for c in components %}
    {{ c.enum }},
    {%- endfor %}
    ;

    public companion object {
        /**
         * Converts from compile-time generic vehicle component type. 
         */
        public inline fun <reified T: VehicleComponent> from(): VehicleComponentType {
            return when ( T::class ) {
                {%- for c in components %}
                {{ c.component }}::class -> VehicleComponentType.{{ c.enum }}
                {%- endfor %}
                else -> throw Exception("Unknown component type")
            }
        }
    }
}

/**
 * Component interface
 */
public interface VehicleComponent {

}


/**
 * Archetype, contains set of possible component storages.
 * Components stored in packed struct-of-arrays format.
 * Element Id used to lookup packed index.
 */
public class ArchetypeStorage(
    val layout: EnumSet<VehicleComponentType>,
    val maxElements: Int,
) {
    public var size: Int = 0
        private set // outside should never change size
    
    // map from vehicle element id => element's dense array index
    // TODO: replace with specialized Densemap
    public val lookup: HashMap<VehicleElementId, Int> = HashMap()

    // dense packed element ids
    public val elements: IntArray = IntArray(maxElements, {_ -> INVALID_ID})

    // dense packed components
    // only components in layout will be non-null
    {%- for c in components %}
    public val {{ c.storage }}: ArrayList<{{ c.component }}>? = if ( layout.contains(VehicleComponentType.{{ c.enum }}) ) ArrayList() else null
    {%- endfor %}
    

    public companion object {
        /**
         * Higher order function that returns a function that gets a
         * Vehicle component type's storage within the archetype.
         * Needed to allows compile-time access to a type's component
         * storage in the archetype. Used for generic tuple iterators.
         * 
         * Internally does unsafe cast, since storages may be null.
         * Client caller must make sure archetypes have the storages.
         * 
         * Note: this may be generating a new lambda object at each call.
         * May want to cache the lambda object, or hard-code each function
         * in future.
         */
        @Suppress("UNCHECKED_CAST")
        public inline fun <reified T> accessor(): (ArchetypeStorage) -> ArrayList<T> {
            return when ( T::class ) {
                {%- for c in components %}
                {{ c.component }}::class -> { archetype -> archetype.{{ c.storage }} as ArrayList<T> }
                {%- endfor %}
                else -> throw Exception("Unknown component type")
            }
        }
    }
}
