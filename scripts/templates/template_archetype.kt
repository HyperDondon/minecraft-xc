/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Archetype style ECS data storage core.
 * 
 * Contains vehicle component enum + interface and archetype storage.
 * 
 * Since component set is finite, just hard-code optional component
 * storages in each archetype. Engine must ensure we only access
 * valid storages in the archetype
 * 
 * See references:
 * https://github.com/amethyst/legion/blob/master/src/internals/storage/archetype.rs
 */

package phonon.xv.core

import java.util.logging.Logger
import java.util.EnumSet
import com.google.gson.JsonObject
import phonon.xv.component.*
import java.util.Stack

// Const indicating invalid dense array index
public const val INVALID_ELEMENT_ID: Int = -1

/**
 * Helper function to push an element into a dense array.
 * Validates that the index is at the end of the array.
 */
private fun <T> ArrayList<T>.pushAtDenseIndex(index: Int, value: T) {
    val storageSize = this.size
    if ( storageSize == index ) {
        this.add(value)
    } else {
        throw IllegalStateException("Archetype storage attempted to insert an element at a dense index larger than current size: ${index} (size = ${storageSize})")
    }
}

/**
 * Helper function to remove an element by swapping it with the last 
 * element in the array.
 */
private fun <T> ArrayList<T>.swapRemove(index: Int) {
    val storageSize = this.size
    if ( storageSize == index ) {
        this.removeAt(index)
    } else {
        // swap with last element
        val last = this[storageSize - 1]
        this[index] = last
        this.removeAt(storageSize - 1)
    }
}

/**
 * Note: keep in alphabetical order.
 */
public enum class VehicleComponentType {
    {%- for c in components %}
    {{ c.enum }},
    {%- endfor %}
    ;

    public companion object {
        /**
         * Converts from compile-time generic vehicle component type. 
         */
        public inline fun <reified T: VehicleComponent<T>> from(): VehicleComponentType {
            return when ( T::class ) {
                {%- for c in components %}
                {{ c.classname }}::class -> VehicleComponentType.{{ c.enum }}
                {%- endfor %}
                else -> throw Exception("Unknown component type")
            }
        }
    }
}

/**
 * Archetype, contains set of possible component storages.
 * Components stored in packed struct-of-arrays format.
 * Element Id used to lookup packed index.
 */
public class ArchetypeStorage(
    val layout: EnumSet<VehicleComponentType>,
    val maxElements: Int,
) {
    public var size: Int = 0
        internal set

    // sparse lookup from id => element
    // (note vehicle element id is just a typealias for int)
    // Internally lookup also stores a linked list of next free element,
    // so initialize with each element pointing to the next element
    // (e.g. next free element is the next element in the array)
    private val lookup: IntArray = IntArray(maxElements, { i -> i + 1 })

    // reverse lookup from dense array index => vehicle element id
    // only internal cuz iterator classes need it
    internal val elements: IntArray = IntArray(maxElements) { _ -> INVALID_ELEMENT_ID }

    // lookup implicit linked list head
    internal var nextFree: Int = 0

    // dense packed components storages
    // only components in layout will be non-null
    {%- for c in components %}
    internal val {{ c.storage }}: ArrayList<{{ c.classname }}>? = if ( layout.contains(VehicleComponentType.{{ c.enum }}) ) ArrayList() else null
    {%- endfor %}

    // public getter "view"s: only expose immutable List interface
    {%- for c in components %}
    public val {{ c.storage }}View: List<{{ c.classname }}>?
        get() = this.{{ c.storage }}
    {%- endfor %}

    /**
     * Get component by id. Returns null if component is not in archetype.
     */
    inline fun <reified T: VehicleComponent<T>> getComponent(id: VehicleElementId): T? {
        val denseIndex = this.getDenseIndex(id)
        if ( denseIndex == INVALID_ELEMENT_ID ) {
            return null
        }
        
        return when ( T::class ) {
            {%- for c in components %}
            {{ c.classname }}::class -> this.{{ c.storage }}View?.get(denseIndex) as T
            {%- endfor %}
            else -> throw Exception("Unknown component type.")
        }
    }

    /**
     * Get dense index from id.
     */
    public fun getDenseIndex(id: VehicleElementId): Int {
        return this.lookup[id]
    }

    /**
     * Insert a prototype into the archetype. Returns a new element id
     * corresponding to its lookup index in the archetype.
     * Returns null if layout does not match or if the archetype is full.
     */
    public fun insert(
        prototype: VehicleElementPrototype,
    ): VehicleElementId? {
        if ( this.layout != prototype.layout ) {
            return null
        }

        // try to allocate a new element id (lookup id)
        if ( size >= maxElements ) {
            return null
        }
        // new id is head of linked list
        val id = nextFree
        // set new head of implicit linked list
        nextFree = lookup[nextFree]
        // get dense index
        val denseIndex = size
        size += 1
        
        // set sparse <-> dense element mappings
        lookup[id] = denseIndex
        elements[denseIndex] = id

        // push prototype components into storages
        for ( c in prototype.layout ) {
            when ( c ) {
                {%- for c in components %}
                VehicleComponentType.{{ c.enum }} -> {
                    this.{{ c.storage }}?.pushAtDenseIndex(denseIndex, prototype.{{ c.storage }}!!)
                }
                {% endfor %}
                null -> {}
            }
        }

        return id
    }

    /**
     * Frees an element from the archetype. Removes all components
     * and frees element id.
     */
    public fun free(id: VehicleElementId, logger: Logger? = null) {
        // validate id is inside storage
        if ( id < 0 || id >= maxElements ) {
            logger?.severe("Archetype.remove() invalid element id: $id")
            return
        }

        // validate id inside dense array == id
        val denseIndex = lookup[id]
        if ( elements[denseIndex] != id ) {
            logger?.severe("Archetype.remove() element id not in array: $id")
            return
        }

        // swap values in dense array w/ last elt
        val lastDenseIndex = size - 1
        val lastId = elements[lastDenseIndex]
        elements[denseIndex] = lastId
        elements[lastDenseIndex] = INVALID_ELEMENT_ID

        // update lookup and implicit list head
        lookup[id] = nextFree
        nextFree = id
        lookup[lastId] = denseIndex

        // swap remove elements in component arrays
        for ( c in layout ) {
            when ( c ) {
                {%- for c in components %}
                VehicleComponentType.{{ c.enum }} -> {{ c.storage }}?.swapRemove(denseIndex)
                {%- endfor %}
                null -> {}
            }
        }
        
        // decrement archetype size
        size -= 1
    }
    
    /**
     * Remove all elements from archetype.
     */
    public fun clear() {
        size = 0

        // reset lookup implicit linked
        for ( i in 0 until maxElements ) {
            lookup[i] = i + 1
            elements[i] = INVALID_ELEMENT_ID
        }
        nextFree = 0

        {%- for c in components %}
        {{ c.storage }}?.clear()
        {%- endfor %}
    }

    public companion object {
        /**
         * Higher order function that returns a function that gets a
         * Vehicle component type's storage within the archetype.
         * Needed to allows compile-time access to a type's component
         * storage in the archetype. Used for generic tuple iterators.
         * 
         * Internally does unsafe cast, since storages may be null.
         * Client caller must make sure archetypes have the storages.
         * 
         * Note: this may be generating a new lambda object at each call.
         * May want to cache the lambda object, or hard-code each function
         * in future.
         */
        @Suppress("UNCHECKED_CAST")
        public inline fun <reified T> accessor(): (ArchetypeStorage) -> List<T> {
            return when ( T::class ) {
                {%- for c in components %}
                {{ c.classname }}::class -> { archetype -> archetype.{{ c.storage }}View as List<T> }
                {%- endfor %}
                else -> throw Exception("Unknown component type")
            }
        }
    }
}
