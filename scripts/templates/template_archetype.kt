/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Archetype style ECS data storage core.
 * 
 * Contains vehicle component enum + interface and archetype storage.
 * 
 * Since component set is finite, just hard-code optional component
 * storages in each archetype. Engine must ensure we only access
 * valid storages in the archetype
 * 
 * See references:
 * https://github.com/amethyst/legion/blob/master/src/internals/storage/archetype.rs
 */

package phonon.xv.core

import java.util.EnumSet
import phonon.xv.core.INVALID_ELEMENT_ID
import phonon.xv.component.*
import java.util.Stack

public const val INVALID_DENSE_INDEX: Int = -1

/**
 * Note: keep in alphabetical order.
 */
public enum class VehicleComponentType {
    {%- for c in components %}
    {{ c.enum }},
    {%- endfor %}
    ;

    public companion object {
        /**
         * Converts from compile-time generic vehicle component type. 
         */
        public inline fun <reified T: VehicleComponent> from(): VehicleComponentType {
            return when ( T::class ) {
                {%- for c in components %}
                {{ c.classname }}::class -> VehicleComponentType.{{ c.enum }}
                {%- endfor %}
                else -> throw Exception("Unknown component type")
            }
        }
    }
}

/**
 * Component interface
 */
public interface VehicleComponent {
    // Vehicle component type enum.
    val type: VehicleComponentType
}

/**
 * Archetype, contains set of possible component storages.
 * Components stored in packed struct-of-arrays format.
 * Element Id used to lookup packed index.
 */
public class ArchetypeStorage(
    val layout: EnumSet<VehicleComponentType>,
    val maxElements: Int,
) {
    public var size: Int = 0
        // private set // TODO: when implemented, outside should never change size

    // fluffy start, vehicle element id manager + dense map/array

    // element id => element
    val lookup: HashMap<VehicleElementId, VehicleElement> = HashMap()
    // stack of free ids that are not at the end of the lookup array
    // lookup array vehicle element id => dense array index
    // the sets we're mapping have equal cardinality, we use a dense map
    // to keep all components in contiguous block in dense array
    private val denseLookup: Array<Int> = Array(maxElements) { _ -> INVALID_DENSE_INDEX }

    // dense array index => vehicle element id
    // only internal cuz iterator classes need it
    internal val elements: IntArray = IntArray(maxElements) { _ -> INVALID_ELEMENT_ID }
    // denseLookup implicit linked list head
    private var freedNext: Int = 0

    /*
    // map from vehicle element id => element's dense array index
    // TODO: replace with specialized Densemap
    public val lookup: HashMap<VehicleElementId, Int> = HashMap()

    // dense packed element ids
    public val elements: IntArray = IntArray(maxElements, {_ -> INVALID_ELEMENT_ID})
    */

    // dense packed components
    // only components in layout will be non-null
    {%- for c in components %}
    public val {{ c.storage }}: ArrayList<{{ c.classname }}>? = if ( layout.contains(VehicleComponentType.{{ c.enum }}) ) ArrayList() else null
    {%- endfor %}

    // element id => element lookup, function for type safety
    fun lookup(id: VehicleElementId): VehicleElement? {
        return lookup[id]
    }

    // reserves a new element id and internally adds an entry in dense array
    // YOU NEED TO UPDATE THE LOOKUP MAP YOURSELF!
    public fun newId(): VehicleElementId {
        if ( size >= MAX_VEHICLE_ELEMENTS )
            return INVALID_ELEMENT_ID
        // new id is head of linked list
        val newId = freedNext
        // update dense array
        elements[size] = newId
        // set new head of implicit linked list
        freedNext = denseLookup[freedNext]
        if ( freedNext == -1 ) {
            freedNext = size + 1
        }
        // update dense lookup
        denseLookup[newId] = size
        size++
        return newId
    }

    // inject the vehicle element w/ its component data
    // into the archetype storage, this is assuming we've
    // already called newId() to reserve its id
    public fun inject(
            element: VehicleElement,
            {%- for c in components %}
            {{ c.storage }}: {{ c.classname }}?,
            {%- endfor %}
    ) {
        this.lookup[element.id] = element
        val denseIndex = denseLookup[element.id]
        {%- for c in components %}
        if ( {{ c.storage }} != null ) {
            val storageSize = this.{{ c.storage }}!!.size
            if (storageSize == denseIndex) {
                this.{{ c.storage }}.add({{ c.storage }})
            } else if (storageSize < denseIndex) {
                throw IllegalStateException("Archetype storage attempted to insert an element at a dense index larger than current size. index: ${denseIndex}")
            } else {
                this.{{ c.storage }}.set(denseIndex, {{ c.storage }})
            }
        }
        {%- endfor %}
    }

    // mark id as deleted
    public fun freeId(id: VehicleElementId) {
        lookup.remove(id)
        // index in dense array to delete
        val index = denseLookup[id]
        // swap values in dense array w/ last elt
        val idAtLast = elements[size - 1]
        elements[index] = idAtLast
        elements[size - 1] = -1
        // update in dense lookup and implicit list head
        denseLookup[id] = freedNext
        freedNext = id
        denseLookup[idAtLast] = index
        // make the swap in component arrays
        {%- for c in components %}
        {{ c.storage }}!!.set(index, {{ c.storage }}.get(size - 1))
        {{ c.storage }}.removeAt(size - 1)
        {%- endfor %}
        size--
    }

    // fluffy end
    
    /**
     * Remove all elements from archetype.
     */
    public fun clear() {
        size = 0
        lookup.clear()

        {%- for c in components %}
        {{ c.storage }}?.clear()
        {%- endfor %}
    }

    public companion object {
        /**
         * Higher order function that returns a function that gets a
         * Vehicle component type's storage within the archetype.
         * Needed to allows compile-time access to a type's component
         * storage in the archetype. Used for generic tuple iterators.
         * 
         * Internally does unsafe cast, since storages may be null.
         * Client caller must make sure archetypes have the storages.
         * 
         * Note: this may be generating a new lambda object at each call.
         * May want to cache the lambda object, or hard-code each function
         * in future.
         */
        @Suppress("UNCHECKED_CAST")
        public inline fun <reified T> accessor(): (ArchetypeStorage) -> ArrayList<T> {
            return when ( T::class ) {
                {%- for c in components %}
                {{ c.classname }}::class -> { archetype -> archetype.{{ c.storage }} as ArrayList<T> }
                {%- endfor %}
                else -> throw Exception("Unknown component type")
            }
        }
    }
}
