/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Implements a "prototype" which is a cached base configuration
 * for a vehicle. This is used to create new vehicles. Rough process
 * involves using prototype as base then injecting specific data
 * for vehicle creation.
 * 
 *               Spawning                 Spawning from
 *              from item:                  save data
 * 
 *              prototype                   prototype 
 *                  |                           |     
 *                  |                           |     
 *     item         v              save         v     
 *     data ------> +              data ------> +     
 *                  |                           |     
 *                  |                           |     
 *    player        v                           |     
 *    event ------> +                           |     
 *     data         |                           |     
 *                  |                           |     
 *                  v                           v     
 *              components                  components
 */

package phonon.xv.core

import java.nio.file.Path
import java.util.EnumSet
import java.util.logging.Logger
import org.tomlj.Toml
import org.tomlj.TomlTable
import phonon.xv.XV
import phonon.xv.component.*
import java.util.LinkedList
import java.util.Queue


/**
 * VehiclePrototype defines elements in a vehicle. Used as a base
 * object to create new vehicles.
 */
public data class VehiclePrototype(
    val name: String,
    val elements: Array<VehicleElementPrototype>,
) {

    val rootElements: Array<VehicleElementPrototype> = elements.filter { e -> e.parent == null }.toTypedArray()

    companion object {
        /**
         * Try to load a vehicle prototype from a toml file.
         * If any of the internal elements fails to parse, this will
         * print an error and return a null.
         */
        public fun fromTomlFile(source: Path, logger: Logger? = null): VehiclePrototype? {
            try {
                val toml = Toml.parse(source)

                val name = toml.getString("name") ?: ""

                val childParentMap = HashMap<String, ArrayList<String>>() // parent->child
                // if this contains an elements table, parse each element
                // else, parse entire doc as single toml table
                val elementsMap: Map<String, VehicleElementPrototype> = if ( toml.getArray("elements") != null ) {
                    toml.getArray("elements")?.let { elems ->
                        ( 0 until elems.size() )
                                .map { i ->
                                    val elt = VehicleElementPrototype.fromToml(elems.getTable(i), vehicleName = name)
                                    if ( elt.parent != null ) {
                                        if ( childParentMap[elt.parent] == null ) {
                                            childParentMap[elt.parent] = ArrayList()
                                        }
                                        childParentMap[elt.parent]!!.add(elt.name)
                                    }
                                    elt.name to elt
                                }.toMap()
                    }!!
                } else {
                    val elt = VehicleElementPrototype.fromToml(toml, vehicleName = name)
                    mapOf(Pair(elt.name, elt))
                }
                val elements = elementsMap.values.toTypedArray()

                // build children list
                for ( e in elements ) {
                    val childNameList = childParentMap[e.name]
                    if ( childNameList == null ) {
                        e.children = Array(0) { null!! } // 0_0
                        continue;
                    }
                    val children = childNameList.stream()
                            .map { n -> elementsMap[n]!! }
                            .toList()
                    e.children = children.toTypedArray()
                }

                // what 3am coding does to a mf
                // this is topological sort to create build order
                // for element prototypes
                // instead u can just construct this top-down from the root nodes
                // truly.... just fucking stupid retard moment...
                /*
                // we're gonna sort the elements so that we build children
                // first then parents in the tree

                // we build a graph of elements, element.parent are directed edges
                // use topological sort to sort array
                val graph = HashMap<String, String>() // children -> parent
                val indegree = HashMap<String, Int>()
                val reverse = HashMap<String, ArrayList<String>>() // parent -> children
                // build the graph
                elementsMap.values.forEach { e ->
                    if ( !indegree.containsKey(e.name) ) {
                        indegree[e.name] = 0
                    }

                    if ( e.parent != null ) {
                        graph[e.name] = e.parent
                        if ( !reverse.containsKey(e.parent) ) {
                            reverse[e.parent] = ArrayList()
                        }
                        reverse[e.parent]!!.add(e.name)
                        if ( !indegree.containsKey(e.parent) ) {
                            indegree[e.parent] = 0
                        }
                        indegree[e.parent] = indegree[e.parent]!! + 1
                    }
                }
                // kahn's algo, O(V+E)
                // basically, push all nodes w/ indegree 0 to queue
                // process nodes on queue, remove processed nodes and
                // incident edges from graph & update indegree, push
                // nodes w/ indegree 0 to stack, then we're done!

                // push all nodes of indegree 0 onto queue
                val queue: Queue<String> = LinkedList()
                for ((key, num) in indegree) {
                    if (num == 0)
                        queue.add(key)
                }
                val elements = ArrayList<VehicleElementPrototype>(elementsMap.keys.size)
                // main algo
                while ( !queue.isEmpty() ) {
                    val next = queue.remove()
                    // update indegrees & push to stack
                    indegree[graph[next]!!] = indegree[graph[next]]!! - 1
                    if ( indegree[graph[next]] == 0 ) {
                        queue.add(graph[next])
                    }
                    // process node
                    elements.add(elementsMap[next]!!)
                }

                // build children list
                for ( e in elements ) {
                    val children = ArrayList<VehicleElementPrototype>()
                    for ( childName in reverse[e.name]!! ) {
                        children.add(elementsMap[childName]!!)
                    }
                    e.children = children.toTypedArray()
                }*/

                return VehiclePrototype(name, elementsMap.values.toTypedArray())
            } catch (e: Exception) {
                logger?.warning("Failed to parse landmine file: ${source.toString()}, ${e}")
                e.printStackTrace()
                return null
            }
        }
    }
}

/**
 * VehicleElementPrototype defines a vehicle element's initial components.
 * Contains all possible components, but only the ones in layout should
 * be non-null.
 */
public data class VehicleElementPrototype(
    val name: String,
    val parent: String?,
    val vehicle: String,
    val layout: EnumSet<VehicleComponentType>,
    {%- for c in components %}
    val {{ c.storage }}: {{ c.classname }}? = null,
    {%- endfor %}
) {

    // DONT SET THIS SHIT!!!
    var children: Array<VehicleElementPrototype>? = null
    internal set

    fun buildCopy(): VehicleElement {
        val childrenElts = ArrayList<VehicleElement>()
        // build children first
        for ( childPrototype in this.children!! ) {
            val elt = childPrototype.buildCopy()
            childrenElts.add(elt)
        }
        val id = XV.storage.lookup[layout]!!.newId()
        val elt = VehicleElement(
                "${vehicle}.${name}${id}",
                id,
                this,
                childrenElts.toTypedArray()
        )
        // go for another pass thru and set parent of children
        for ( child in childrenElts ) {
            child.parent = elt
        }
        return elt
    }

    companion object {
        public fun fromToml(toml: TomlTable, logger: Logger? = null, vehicleName: String): VehicleElementPrototype {
            // element built-in properties
            val name = toml.getString("name") ?: ""
            val parent = toml.getString("parent")
            
            // all possible components to be parsed
            {%- for c in components %}
            var {{ c.storage }}: {{ c.classname }}? = null
            {%- endfor %}

            // parse components from matching keys in toml
            val layout = EnumSet.noneOf(VehicleComponentType::class.java)
            val keys = toml.keySet()
            for ( k in keys ) {
                when ( k ) {
                    "name", "parent" -> continue
                    {%- for c in components %}
                    "{{ c.config_name }}" -> {
                        layout.add(VehicleComponentType.{{ c.enum }})
                        {{ c.storage }} = {{ c.classname }}.fromToml(toml.getTable(k)!!, logger)
                    }
                    {%- endfor %}
                    else -> logger?.warning("Unknown key in vehicle element: $k")
                }
            }
            
            return VehicleElementPrototype(
                name,
                parent,
                vehicleName,
                layout,
                {%- for c in components %}
                {{ c.storage }},
                {%- endfor %}
            )
        }
    }
}
