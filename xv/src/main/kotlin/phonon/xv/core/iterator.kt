/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TUPLE SIZES `A, B, C, ...`. DO NOT EDIT THIS
 * FILE DIRECTLY.
 * 
 * Contains hard-coded generics component tuples and iterators
 * for iterating over a set of distinct component types.
 * This avoids runtime type casting for different component tuple
 * sizes in system function component iterator queries:
 * 
 * Without hard-coded generics, if we wanted a general function that
 * could iterate over a set of components defined by a vararg of enums,
 * 
 *      for (a, b, c) in components.query(Type.A, Type.B, Type.C) {
 *         // ...                     ^
 *      }                             |
 *                                    |
 *                       Must return different iterator types
 *                       for (a,), (a, b), (a, b, c), ...
 *                       How can same function have different
 *                       return types?
 * 
 * This is a limitation of Kotlin/Java type system. Even if it worked, it
 * would require some forms of runtime type casting.
 * 
 * Instead, hard-code each generic `ComponentTupleN` for N components.
 * The iterator now looks like:
 * 
 *      for (a, b, c) in ComponentTuple3<A, B, C>.query(components) {
 *         // ...
 *      }
 * 
 * This is more annoying since we have to type the specific "N" size,
 * but this allows us to avoid any runtime type casting and now allows
 * iterating different component tuple sizes.
 */

package phonon.xv.core.iter

import java.util.EnumSet
import phonon.xv.core.*

/**
 * TODO: do we even need?
 */
interface ComponentTuple {
    
}


public data class ComponentTuple1<
    A: VehicleComponent<A>,
>(
    val element: VehicleElementId,
    val a: A,
): ComponentTuple {
    
    companion object {
        /**
         * Note: this could be cached as a Query class.
         * Query would need to support being re-created if engine reloads
         * vehicle element types.
         */
        public inline fun <
            reified A: VehicleComponent<A>,
        > query(components: ComponentsStorage): ComponentTuple1Iterator<A> {
            val layout = EnumSet.of(
                VehicleComponentType.from<A>(),
            )
            
            val getStorageA: (ArchetypeStorage) -> List<A> = ArchetypeStorage.accessor()

            return ComponentTuple1Iterator<A>(
                layout,
                components,
                getStorageA,
            )
        }
    }
}


class ComponentTuple1Iterator<
    A: VehicleComponent<A>,
>(
    val layout: EnumSet<VehicleComponentType>,
    val components: ComponentsStorage,
    val getStorageA: (ArchetypeStorage) -> List<A>,
): Iterator<ComponentTuple1<A>> {
    // get list of matching archetypes. simplifies logic because
    // `hasNext` must always know if there is a "next" valid archetype
    // that needs to be traversed.
    // TODO: this could be cached in a query object that creates the iterator
    val validArchetypes = components.getMatchingArchetypes(layout).filter { it.size > 0 }

    // archetype index within valid archetypes
    var currArchetypeIndex = 0
    
    // current archetype's relevent storages
    var currElementCount: Int = 0
    var currElementIds: IntArray? = null
    var currStorageA: List<A>? = null
    // index within an archetype's storage
    var elementIndex = 0

    init {
        // initialize with first valid archetype
        if ( validArchetypes.size > 0 ) {
            val archetype = validArchetypes[currArchetypeIndex]
            currElementCount = archetype.size
            currElementIds = archetype.elements
            currStorageA = getStorageA(archetype)
        }
    }

    override fun hasNext(): Boolean {
        return currArchetypeIndex < validArchetypes.size && elementIndex < currElementCount
    }

    override fun next(): ComponentTuple1<A> {
        val id = currElementIds!![elementIndex]
        val a = currStorageA!![elementIndex]
        elementIndex += 1

        // finished with this archetype, move to next
        if ( elementIndex >= currElementCount ) {
            currArchetypeIndex += 1
            
            if ( currArchetypeIndex < validArchetypes.size ) {
                val archetype = validArchetypes[currArchetypeIndex]
                currElementCount = archetype.size
                currElementIds = archetype.elements
                currStorageA = getStorageA(archetype)
    
                elementIndex = 0
            }
        }
        
        return ComponentTuple1(id, a)
    }
}

public data class ComponentTuple2<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
>(
    val element: VehicleElementId,
    val a: A,
    val b: B,
): ComponentTuple {
    
    companion object {
        /**
         * Note: this could be cached as a Query class.
         * Query would need to support being re-created if engine reloads
         * vehicle element types.
         */
        public inline fun <
            reified A: VehicleComponent<A>,
            reified B: VehicleComponent<B>,
        > query(components: ComponentsStorage): ComponentTuple2Iterator<A, B> {
            val layout = EnumSet.of(
                VehicleComponentType.from<A>(),
                VehicleComponentType.from<B>(),
            )
            
            val getStorageA: (ArchetypeStorage) -> List<A> = ArchetypeStorage.accessor()
            val getStorageB: (ArchetypeStorage) -> List<B> = ArchetypeStorage.accessor()

            return ComponentTuple2Iterator<A, B>(
                layout,
                components,
                getStorageA,
                getStorageB,
            )
        }
    }
}


class ComponentTuple2Iterator<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
>(
    val layout: EnumSet<VehicleComponentType>,
    val components: ComponentsStorage,
    val getStorageA: (ArchetypeStorage) -> List<A>,
    val getStorageB: (ArchetypeStorage) -> List<B>,
): Iterator<ComponentTuple2<A, B>> {
    // get list of matching archetypes. simplifies logic because
    // `hasNext` must always know if there is a "next" valid archetype
    // that needs to be traversed.
    // TODO: this could be cached in a query object that creates the iterator
    val validArchetypes = components.getMatchingArchetypes(layout).filter { it.size > 0 }

    // archetype index within valid archetypes
    var currArchetypeIndex = 0
    
    // current archetype's relevent storages
    var currElementCount: Int = 0
    var currElementIds: IntArray? = null
    var currStorageA: List<A>? = null
    var currStorageB: List<B>? = null
    // index within an archetype's storage
    var elementIndex = 0

    init {
        // initialize with first valid archetype
        if ( validArchetypes.size > 0 ) {
            val archetype = validArchetypes[currArchetypeIndex]
            currElementCount = archetype.size
            currElementIds = archetype.elements
            currStorageA = getStorageA(archetype)
            currStorageB = getStorageB(archetype)
        }
    }

    override fun hasNext(): Boolean {
        return currArchetypeIndex < validArchetypes.size && elementIndex < currElementCount
    }

    override fun next(): ComponentTuple2<A, B> {
        val id = currElementIds!![elementIndex]
        val a = currStorageA!![elementIndex]
        val b = currStorageB!![elementIndex]
        elementIndex += 1

        // finished with this archetype, move to next
        if ( elementIndex >= currElementCount ) {
            currArchetypeIndex += 1
            
            if ( currArchetypeIndex < validArchetypes.size ) {
                val archetype = validArchetypes[currArchetypeIndex]
                currElementCount = archetype.size
                currElementIds = archetype.elements
                currStorageA = getStorageA(archetype)
                currStorageB = getStorageB(archetype)
    
                elementIndex = 0
            }
        }
        
        return ComponentTuple2(id, a, b)
    }
}

public data class ComponentTuple3<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
    C: VehicleComponent<C>,
>(
    val element: VehicleElementId,
    val a: A,
    val b: B,
    val c: C,
): ComponentTuple {
    
    companion object {
        /**
         * Note: this could be cached as a Query class.
         * Query would need to support being re-created if engine reloads
         * vehicle element types.
         */
        public inline fun <
            reified A: VehicleComponent<A>,
            reified B: VehicleComponent<B>,
            reified C: VehicleComponent<C>,
        > query(components: ComponentsStorage): ComponentTuple3Iterator<A, B, C> {
            val layout = EnumSet.of(
                VehicleComponentType.from<A>(),
                VehicleComponentType.from<B>(),
                VehicleComponentType.from<C>(),
            )
            
            val getStorageA: (ArchetypeStorage) -> List<A> = ArchetypeStorage.accessor()
            val getStorageB: (ArchetypeStorage) -> List<B> = ArchetypeStorage.accessor()
            val getStorageC: (ArchetypeStorage) -> List<C> = ArchetypeStorage.accessor()

            return ComponentTuple3Iterator<A, B, C>(
                layout,
                components,
                getStorageA,
                getStorageB,
                getStorageC,
            )
        }
    }
}


class ComponentTuple3Iterator<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
    C: VehicleComponent<C>,
>(
    val layout: EnumSet<VehicleComponentType>,
    val components: ComponentsStorage,
    val getStorageA: (ArchetypeStorage) -> List<A>,
    val getStorageB: (ArchetypeStorage) -> List<B>,
    val getStorageC: (ArchetypeStorage) -> List<C>,
): Iterator<ComponentTuple3<A, B, C>> {
    // get list of matching archetypes. simplifies logic because
    // `hasNext` must always know if there is a "next" valid archetype
    // that needs to be traversed.
    // TODO: this could be cached in a query object that creates the iterator
    val validArchetypes = components.getMatchingArchetypes(layout).filter { it.size > 0 }

    // archetype index within valid archetypes
    var currArchetypeIndex = 0
    
    // current archetype's relevent storages
    var currElementCount: Int = 0
    var currElementIds: IntArray? = null
    var currStorageA: List<A>? = null
    var currStorageB: List<B>? = null
    var currStorageC: List<C>? = null
    // index within an archetype's storage
    var elementIndex = 0

    init {
        // initialize with first valid archetype
        if ( validArchetypes.size > 0 ) {
            val archetype = validArchetypes[currArchetypeIndex]
            currElementCount = archetype.size
            currElementIds = archetype.elements
            currStorageA = getStorageA(archetype)
            currStorageB = getStorageB(archetype)
            currStorageC = getStorageC(archetype)
        }
    }

    override fun hasNext(): Boolean {
        return currArchetypeIndex < validArchetypes.size && elementIndex < currElementCount
    }

    override fun next(): ComponentTuple3<A, B, C> {
        val id = currElementIds!![elementIndex]
        val a = currStorageA!![elementIndex]
        val b = currStorageB!![elementIndex]
        val c = currStorageC!![elementIndex]
        elementIndex += 1

        // finished with this archetype, move to next
        if ( elementIndex >= currElementCount ) {
            currArchetypeIndex += 1
            
            if ( currArchetypeIndex < validArchetypes.size ) {
                val archetype = validArchetypes[currArchetypeIndex]
                currElementCount = archetype.size
                currElementIds = archetype.elements
                currStorageA = getStorageA(archetype)
                currStorageB = getStorageB(archetype)
                currStorageC = getStorageC(archetype)
    
                elementIndex = 0
            }
        }
        
        return ComponentTuple3(id, a, b, c)
    }
}

public data class ComponentTuple4<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
    C: VehicleComponent<C>,
    D: VehicleComponent<D>,
>(
    val element: VehicleElementId,
    val a: A,
    val b: B,
    val c: C,
    val d: D,
): ComponentTuple {
    
    companion object {
        /**
         * Note: this could be cached as a Query class.
         * Query would need to support being re-created if engine reloads
         * vehicle element types.
         */
        public inline fun <
            reified A: VehicleComponent<A>,
            reified B: VehicleComponent<B>,
            reified C: VehicleComponent<C>,
            reified D: VehicleComponent<D>,
        > query(components: ComponentsStorage): ComponentTuple4Iterator<A, B, C, D> {
            val layout = EnumSet.of(
                VehicleComponentType.from<A>(),
                VehicleComponentType.from<B>(),
                VehicleComponentType.from<C>(),
                VehicleComponentType.from<D>(),
            )
            
            val getStorageA: (ArchetypeStorage) -> List<A> = ArchetypeStorage.accessor()
            val getStorageB: (ArchetypeStorage) -> List<B> = ArchetypeStorage.accessor()
            val getStorageC: (ArchetypeStorage) -> List<C> = ArchetypeStorage.accessor()
            val getStorageD: (ArchetypeStorage) -> List<D> = ArchetypeStorage.accessor()

            return ComponentTuple4Iterator<A, B, C, D>(
                layout,
                components,
                getStorageA,
                getStorageB,
                getStorageC,
                getStorageD,
            )
        }
    }
}


class ComponentTuple4Iterator<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
    C: VehicleComponent<C>,
    D: VehicleComponent<D>,
>(
    val layout: EnumSet<VehicleComponentType>,
    val components: ComponentsStorage,
    val getStorageA: (ArchetypeStorage) -> List<A>,
    val getStorageB: (ArchetypeStorage) -> List<B>,
    val getStorageC: (ArchetypeStorage) -> List<C>,
    val getStorageD: (ArchetypeStorage) -> List<D>,
): Iterator<ComponentTuple4<A, B, C, D>> {
    // get list of matching archetypes. simplifies logic because
    // `hasNext` must always know if there is a "next" valid archetype
    // that needs to be traversed.
    // TODO: this could be cached in a query object that creates the iterator
    val validArchetypes = components.getMatchingArchetypes(layout).filter { it.size > 0 }

    // archetype index within valid archetypes
    var currArchetypeIndex = 0
    
    // current archetype's relevent storages
    var currElementCount: Int = 0
    var currElementIds: IntArray? = null
    var currStorageA: List<A>? = null
    var currStorageB: List<B>? = null
    var currStorageC: List<C>? = null
    var currStorageD: List<D>? = null
    // index within an archetype's storage
    var elementIndex = 0

    init {
        // initialize with first valid archetype
        if ( validArchetypes.size > 0 ) {
            val archetype = validArchetypes[currArchetypeIndex]
            currElementCount = archetype.size
            currElementIds = archetype.elements
            currStorageA = getStorageA(archetype)
            currStorageB = getStorageB(archetype)
            currStorageC = getStorageC(archetype)
            currStorageD = getStorageD(archetype)
        }
    }

    override fun hasNext(): Boolean {
        return currArchetypeIndex < validArchetypes.size && elementIndex < currElementCount
    }

    override fun next(): ComponentTuple4<A, B, C, D> {
        val id = currElementIds!![elementIndex]
        val a = currStorageA!![elementIndex]
        val b = currStorageB!![elementIndex]
        val c = currStorageC!![elementIndex]
        val d = currStorageD!![elementIndex]
        elementIndex += 1

        // finished with this archetype, move to next
        if ( elementIndex >= currElementCount ) {
            currArchetypeIndex += 1
            
            if ( currArchetypeIndex < validArchetypes.size ) {
                val archetype = validArchetypes[currArchetypeIndex]
                currElementCount = archetype.size
                currElementIds = archetype.elements
                currStorageA = getStorageA(archetype)
                currStorageB = getStorageB(archetype)
                currStorageC = getStorageC(archetype)
                currStorageD = getStorageD(archetype)
    
                elementIndex = 0
            }
        }
        
        return ComponentTuple4(id, a, b, c, d)
    }
}

public data class ComponentTuple5<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
    C: VehicleComponent<C>,
    D: VehicleComponent<D>,
    E: VehicleComponent<E>,
>(
    val element: VehicleElementId,
    val a: A,
    val b: B,
    val c: C,
    val d: D,
    val e: E,
): ComponentTuple {
    
    companion object {
        /**
         * Note: this could be cached as a Query class.
         * Query would need to support being re-created if engine reloads
         * vehicle element types.
         */
        public inline fun <
            reified A: VehicleComponent<A>,
            reified B: VehicleComponent<B>,
            reified C: VehicleComponent<C>,
            reified D: VehicleComponent<D>,
            reified E: VehicleComponent<E>,
        > query(components: ComponentsStorage): ComponentTuple5Iterator<A, B, C, D, E> {
            val layout = EnumSet.of(
                VehicleComponentType.from<A>(),
                VehicleComponentType.from<B>(),
                VehicleComponentType.from<C>(),
                VehicleComponentType.from<D>(),
                VehicleComponentType.from<E>(),
            )
            
            val getStorageA: (ArchetypeStorage) -> List<A> = ArchetypeStorage.accessor()
            val getStorageB: (ArchetypeStorage) -> List<B> = ArchetypeStorage.accessor()
            val getStorageC: (ArchetypeStorage) -> List<C> = ArchetypeStorage.accessor()
            val getStorageD: (ArchetypeStorage) -> List<D> = ArchetypeStorage.accessor()
            val getStorageE: (ArchetypeStorage) -> List<E> = ArchetypeStorage.accessor()

            return ComponentTuple5Iterator<A, B, C, D, E>(
                layout,
                components,
                getStorageA,
                getStorageB,
                getStorageC,
                getStorageD,
                getStorageE,
            )
        }
    }
}


class ComponentTuple5Iterator<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
    C: VehicleComponent<C>,
    D: VehicleComponent<D>,
    E: VehicleComponent<E>,
>(
    val layout: EnumSet<VehicleComponentType>,
    val components: ComponentsStorage,
    val getStorageA: (ArchetypeStorage) -> List<A>,
    val getStorageB: (ArchetypeStorage) -> List<B>,
    val getStorageC: (ArchetypeStorage) -> List<C>,
    val getStorageD: (ArchetypeStorage) -> List<D>,
    val getStorageE: (ArchetypeStorage) -> List<E>,
): Iterator<ComponentTuple5<A, B, C, D, E>> {
    // get list of matching archetypes. simplifies logic because
    // `hasNext` must always know if there is a "next" valid archetype
    // that needs to be traversed.
    // TODO: this could be cached in a query object that creates the iterator
    val validArchetypes = components.getMatchingArchetypes(layout).filter { it.size > 0 }

    // archetype index within valid archetypes
    var currArchetypeIndex = 0
    
    // current archetype's relevent storages
    var currElementCount: Int = 0
    var currElementIds: IntArray? = null
    var currStorageA: List<A>? = null
    var currStorageB: List<B>? = null
    var currStorageC: List<C>? = null
    var currStorageD: List<D>? = null
    var currStorageE: List<E>? = null
    // index within an archetype's storage
    var elementIndex = 0

    init {
        // initialize with first valid archetype
        if ( validArchetypes.size > 0 ) {
            val archetype = validArchetypes[currArchetypeIndex]
            currElementCount = archetype.size
            currElementIds = archetype.elements
            currStorageA = getStorageA(archetype)
            currStorageB = getStorageB(archetype)
            currStorageC = getStorageC(archetype)
            currStorageD = getStorageD(archetype)
            currStorageE = getStorageE(archetype)
        }
    }

    override fun hasNext(): Boolean {
        return currArchetypeIndex < validArchetypes.size && elementIndex < currElementCount
    }

    override fun next(): ComponentTuple5<A, B, C, D, E> {
        val id = currElementIds!![elementIndex]
        val a = currStorageA!![elementIndex]
        val b = currStorageB!![elementIndex]
        val c = currStorageC!![elementIndex]
        val d = currStorageD!![elementIndex]
        val e = currStorageE!![elementIndex]
        elementIndex += 1

        // finished with this archetype, move to next
        if ( elementIndex >= currElementCount ) {
            currArchetypeIndex += 1
            
            if ( currArchetypeIndex < validArchetypes.size ) {
                val archetype = validArchetypes[currArchetypeIndex]
                currElementCount = archetype.size
                currElementIds = archetype.elements
                currStorageA = getStorageA(archetype)
                currStorageB = getStorageB(archetype)
                currStorageC = getStorageC(archetype)
                currStorageD = getStorageD(archetype)
                currStorageE = getStorageE(archetype)
    
                elementIndex = 0
            }
        }
        
        return ComponentTuple5(id, a, b, c, d, e)
    }
}

public data class ComponentTuple6<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
    C: VehicleComponent<C>,
    D: VehicleComponent<D>,
    E: VehicleComponent<E>,
    F: VehicleComponent<F>,
>(
    val element: VehicleElementId,
    val a: A,
    val b: B,
    val c: C,
    val d: D,
    val e: E,
    val f: F,
): ComponentTuple {
    
    companion object {
        /**
         * Note: this could be cached as a Query class.
         * Query would need to support being re-created if engine reloads
         * vehicle element types.
         */
        public inline fun <
            reified A: VehicleComponent<A>,
            reified B: VehicleComponent<B>,
            reified C: VehicleComponent<C>,
            reified D: VehicleComponent<D>,
            reified E: VehicleComponent<E>,
            reified F: VehicleComponent<F>,
        > query(components: ComponentsStorage): ComponentTuple6Iterator<A, B, C, D, E, F> {
            val layout = EnumSet.of(
                VehicleComponentType.from<A>(),
                VehicleComponentType.from<B>(),
                VehicleComponentType.from<C>(),
                VehicleComponentType.from<D>(),
                VehicleComponentType.from<E>(),
                VehicleComponentType.from<F>(),
            )
            
            val getStorageA: (ArchetypeStorage) -> List<A> = ArchetypeStorage.accessor()
            val getStorageB: (ArchetypeStorage) -> List<B> = ArchetypeStorage.accessor()
            val getStorageC: (ArchetypeStorage) -> List<C> = ArchetypeStorage.accessor()
            val getStorageD: (ArchetypeStorage) -> List<D> = ArchetypeStorage.accessor()
            val getStorageE: (ArchetypeStorage) -> List<E> = ArchetypeStorage.accessor()
            val getStorageF: (ArchetypeStorage) -> List<F> = ArchetypeStorage.accessor()

            return ComponentTuple6Iterator<A, B, C, D, E, F>(
                layout,
                components,
                getStorageA,
                getStorageB,
                getStorageC,
                getStorageD,
                getStorageE,
                getStorageF,
            )
        }
    }
}


class ComponentTuple6Iterator<
    A: VehicleComponent<A>,
    B: VehicleComponent<B>,
    C: VehicleComponent<C>,
    D: VehicleComponent<D>,
    E: VehicleComponent<E>,
    F: VehicleComponent<F>,
>(
    val layout: EnumSet<VehicleComponentType>,
    val components: ComponentsStorage,
    val getStorageA: (ArchetypeStorage) -> List<A>,
    val getStorageB: (ArchetypeStorage) -> List<B>,
    val getStorageC: (ArchetypeStorage) -> List<C>,
    val getStorageD: (ArchetypeStorage) -> List<D>,
    val getStorageE: (ArchetypeStorage) -> List<E>,
    val getStorageF: (ArchetypeStorage) -> List<F>,
): Iterator<ComponentTuple6<A, B, C, D, E, F>> {
    // get list of matching archetypes. simplifies logic because
    // `hasNext` must always know if there is a "next" valid archetype
    // that needs to be traversed.
    // TODO: this could be cached in a query object that creates the iterator
    val validArchetypes = components.getMatchingArchetypes(layout).filter { it.size > 0 }

    // archetype index within valid archetypes
    var currArchetypeIndex = 0
    
    // current archetype's relevent storages
    var currElementCount: Int = 0
    var currElementIds: IntArray? = null
    var currStorageA: List<A>? = null
    var currStorageB: List<B>? = null
    var currStorageC: List<C>? = null
    var currStorageD: List<D>? = null
    var currStorageE: List<E>? = null
    var currStorageF: List<F>? = null
    // index within an archetype's storage
    var elementIndex = 0

    init {
        // initialize with first valid archetype
        if ( validArchetypes.size > 0 ) {
            val archetype = validArchetypes[currArchetypeIndex]
            currElementCount = archetype.size
            currElementIds = archetype.elements
            currStorageA = getStorageA(archetype)
            currStorageB = getStorageB(archetype)
            currStorageC = getStorageC(archetype)
            currStorageD = getStorageD(archetype)
            currStorageE = getStorageE(archetype)
            currStorageF = getStorageF(archetype)
        }
    }

    override fun hasNext(): Boolean {
        return currArchetypeIndex < validArchetypes.size && elementIndex < currElementCount
    }

    override fun next(): ComponentTuple6<A, B, C, D, E, F> {
        val id = currElementIds!![elementIndex]
        val a = currStorageA!![elementIndex]
        val b = currStorageB!![elementIndex]
        val c = currStorageC!![elementIndex]
        val d = currStorageD!![elementIndex]
        val e = currStorageE!![elementIndex]
        val f = currStorageF!![elementIndex]
        elementIndex += 1

        // finished with this archetype, move to next
        if ( elementIndex >= currElementCount ) {
            currArchetypeIndex += 1
            
            if ( currArchetypeIndex < validArchetypes.size ) {
                val archetype = validArchetypes[currArchetypeIndex]
                currElementCount = archetype.size
                currElementIds = archetype.elements
                currStorageA = getStorageA(archetype)
                currStorageB = getStorageB(archetype)
                currStorageC = getStorageC(archetype)
                currStorageD = getStorageD(archetype)
                currStorageE = getStorageE(archetype)
                currStorageF = getStorageF(archetype)
    
                elementIndex = 0
            }
        }
        
        return ComponentTuple6(id, a, b, c, d, e, f)
    }
}
