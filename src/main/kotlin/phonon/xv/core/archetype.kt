/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Archetype style ECS data storage core.
 * 
 * Contains vehicle component enum + interface and archetype storage.
 * 
 * Since component set is finite, just hard-code optional component
 * storages in each archetype. Engine must ensure we only access
 * valid storages in the archetype
 * 
 * See references:
 * https://github.com/amethyst/legion/blob/master/src/internals/storage/archetype.rs
 */

package phonon.xv.core

import java.util.UUID
import java.util.logging.Logger
import java.util.EnumSet
import com.google.gson.JsonObject
import org.tomlj.Toml
import org.tomlj.TomlTable
import org.bukkit.Location
import org.bukkit.NamespacedKey
import org.bukkit.entity.Player
import org.bukkit.inventory.ItemStack
import org.bukkit.inventory.meta.ItemMeta
import org.bukkit.persistence.PersistentDataContainer
import org.bukkit.persistence.PersistentDataType
import phonon.xc.XC
import phonon.xv.component.*
import java.util.Stack


/**
 * Helper function to push an element into a dense array.
 * Validates that the index is at the end of the array.
 */
private fun <T> ArrayList<T>.pushAtDenseIndex(index: Int, value: T) {
    val storageSize = this.size
    if ( storageSize == index ) {
        this.add(value)
    } else {
        throw IllegalStateException("Archetype storage attempted to insert an element at a dense index larger than current size: ${index} (size = ${storageSize})")
    }
}

/**
 * Helper function to remove an element by swapping it with the last 
 * element in the array.
 */
private fun <T> ArrayList<T>.swapRemove(index: Int) {
    val storageSize = this.size
    if ( storageSize == 1 ) {
        this.removeAt(0)
    } else {
        // swap with last element
        val last = this[storageSize - 1]
        this[index] = last
        this.removeAt(storageSize - 1)
    }
}

/**
 * Note: keep in alphabetical order.
 */
public enum class VehicleComponentType {
    AMMO,
    AMMO_FIRE_WHEN_LOADED,
    FUEL,
    GRAVITY,
    GUN_BARREL,
    GUN_TURRET,
    HEALTH,
    LAND_MOVEMENT_CONTROLS,
    SHIP_MOVEMENT_CONTROLS,
    MODEL,
    PARTICLES,
    SEATS,
    SEATS_RAYCAST,
    SMOKE_PARTICLES,
    TRANSFORM,
    ;

    public companion object {
        /**
         * Converts from compile-time generic vehicle component type. 
         */
        public inline fun <reified T: VehicleComponent<T>> from(): VehicleComponentType {
            return when ( T::class ) {
                AmmoComponent::class -> VehicleComponentType.AMMO
                AmmoFireWhenLoadedComponent::class -> VehicleComponentType.AMMO_FIRE_WHEN_LOADED
                FuelComponent::class -> VehicleComponentType.FUEL
                GravityComponent::class -> VehicleComponentType.GRAVITY
                GunBarrelComponent::class -> VehicleComponentType.GUN_BARREL
                GunTurretComponent::class -> VehicleComponentType.GUN_TURRET
                HealthComponent::class -> VehicleComponentType.HEALTH
                LandMovementControlsComponent::class -> VehicleComponentType.LAND_MOVEMENT_CONTROLS
                ShipMovementControlsComponent::class -> VehicleComponentType.SHIP_MOVEMENT_CONTROLS
                ModelComponent::class -> VehicleComponentType.MODEL
                ParticlesComponent::class -> VehicleComponentType.PARTICLES
                SeatsComponent::class -> VehicleComponentType.SEATS
                SeatsRaycastComponent::class -> VehicleComponentType.SEATS_RAYCAST
                SmokeParticlesComponent::class -> VehicleComponentType.SMOKE_PARTICLES
                TransformComponent::class -> VehicleComponentType.TRANSFORM
                else -> throw Exception("Unknown component type")
            }
        }
    }
}

// namespaced keys, for use in toItem()
val AMMO_KEY = NamespacedKey("xv", "ammo")
val AMMO_FIRE_WHEN_LOADED_KEY = NamespacedKey("xv", "ammo_fire_when_loaded")
val FUEL_KEY = NamespacedKey("xv", "fuel")
val GRAVITY_KEY = NamespacedKey("xv", "gravity")
val GUN_BARREL_KEY = NamespacedKey("xv", "gun_barrel")
val GUN_TURRET_KEY = NamespacedKey("xv", "gun_turret")
val HEALTH_KEY = NamespacedKey("xv", "health")
val LAND_MOVEMENT_CONTROLS_KEY = NamespacedKey("xv", "land_movement_controls")
val SHIP_MOVEMENT_CONTROLS_KEY = NamespacedKey("xv", "ship_movement_controls")
val MODEL_KEY = NamespacedKey("xv", "model")
val PARTICLES_KEY = NamespacedKey("xv", "particles")
val SEATS_KEY = NamespacedKey("xv", "seats")
val SEATS_RAYCAST_KEY = NamespacedKey("xv", "seats_raycast")
val SMOKE_PARTICLES_KEY = NamespacedKey("xv", "smoke_particles")
val TRANSFORM_KEY = NamespacedKey("xv", "transform")

/**
 * VehicleComponents contains set of all possible components for a vehicle
 * element and a layout EnumSet that indicates the non-null components.
 */
public data class VehicleComponents(
    val layout: EnumSet<VehicleComponentType>,
    val ammo: AmmoComponent? = null,
    val ammoFireWhenLoaded: AmmoFireWhenLoadedComponent? = null,
    val fuel: FuelComponent? = null,
    val gravity: GravityComponent? = null,
    val gunBarrel: GunBarrelComponent? = null,
    val gunTurret: GunTurretComponent? = null,
    val health: HealthComponent? = null,
    val landMovementControls: LandMovementControlsComponent? = null,
    val shipMovementControls: ShipMovementControlsComponent? = null,
    val model: ModelComponent? = null,
    val particles: ParticlesComponent? = null,
    val seats: SeatsComponent? = null,
    val seatsRaycast: SeatsRaycastComponent? = null,
    val smokeParticles: SmokeParticlesComponent? = null,
    val transform: TransformComponent? = null,
) {
    /**
     * Deep-clones all components in this components set.
     */
    fun clone(): VehicleComponents {
        return VehicleComponents(
            layout,
            ammo = ammo?.deepclone(),
            ammoFireWhenLoaded = ammoFireWhenLoaded?.deepclone(),
            fuel = fuel?.deepclone(),
            gravity = gravity?.deepclone(),
            gunBarrel = gunBarrel?.deepclone(),
            gunTurret = gunTurret?.deepclone(),
            health = health?.deepclone(),
            landMovementControls = landMovementControls?.deepclone(),
            shipMovementControls = shipMovementControls?.deepclone(),
            model = model?.deepclone(),
            particles = particles?.deepclone(),
            seats = seats?.deepclone(),
            seatsRaycast = seatsRaycast?.deepclone(),
            smokeParticles = smokeParticles?.deepclone(),
            transform = transform?.deepclone(),
        )
    }

    /**
     * During creation, inject player specific properties and generate
     * a new instance of components. Delegates injecting property
     * effects to each individual component.
     */
    fun injectSpawnProperties(
        location: Location?,
        player: Player?,
    ): VehicleComponents {
        return copy(
            ammo = ammo?.injectSpawnProperties(location, player),
            ammoFireWhenLoaded = ammoFireWhenLoaded?.injectSpawnProperties(location, player),
            fuel = fuel?.injectSpawnProperties(location, player),
            gravity = gravity?.injectSpawnProperties(location, player),
            gunBarrel = gunBarrel?.injectSpawnProperties(location, player),
            gunTurret = gunTurret?.injectSpawnProperties(location, player),
            health = health?.injectSpawnProperties(location, player),
            landMovementControls = landMovementControls?.injectSpawnProperties(location, player),
            shipMovementControls = shipMovementControls?.injectSpawnProperties(location, player),
            model = model?.injectSpawnProperties(location, player),
            particles = particles?.injectSpawnProperties(location, player),
            seats = seats?.injectSpawnProperties(location, player),
            seatsRaycast = seatsRaycast?.injectSpawnProperties(location, player),
            smokeParticles = smokeParticles?.injectSpawnProperties(location, player),
            transform = transform?.injectSpawnProperties(location, player),
        )
    }

    /**
     * During creation, inject item specific properties and generate
     * a new instance of this component. Delegates injecting property
     * effects to each individual component.
     */
    fun injectItemProperties(
        itemData: PersistentDataContainer
    ): VehicleComponents {
        return copy(
            ammo = ammo?.injectItemProperties(itemData.get(AMMO_KEY, PersistentDataType.TAG_CONTAINER)),
            ammoFireWhenLoaded = ammoFireWhenLoaded?.injectItemProperties(itemData.get(AMMO_FIRE_WHEN_LOADED_KEY, PersistentDataType.TAG_CONTAINER)),
            fuel = fuel?.injectItemProperties(itemData.get(FUEL_KEY, PersistentDataType.TAG_CONTAINER)),
            gravity = gravity?.injectItemProperties(itemData.get(GRAVITY_KEY, PersistentDataType.TAG_CONTAINER)),
            gunBarrel = gunBarrel?.injectItemProperties(itemData.get(GUN_BARREL_KEY, PersistentDataType.TAG_CONTAINER)),
            gunTurret = gunTurret?.injectItemProperties(itemData.get(GUN_TURRET_KEY, PersistentDataType.TAG_CONTAINER)),
            health = health?.injectItemProperties(itemData.get(HEALTH_KEY, PersistentDataType.TAG_CONTAINER)),
            landMovementControls = landMovementControls?.injectItemProperties(itemData.get(LAND_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER)),
            shipMovementControls = shipMovementControls?.injectItemProperties(itemData.get(SHIP_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER)),
            model = model?.injectItemProperties(itemData.get(MODEL_KEY, PersistentDataType.TAG_CONTAINER)),
            particles = particles?.injectItemProperties(itemData.get(PARTICLES_KEY, PersistentDataType.TAG_CONTAINER)),
            seats = seats?.injectItemProperties(itemData.get(SEATS_KEY, PersistentDataType.TAG_CONTAINER)),
            seatsRaycast = seatsRaycast?.injectItemProperties(itemData.get(SEATS_RAYCAST_KEY, PersistentDataType.TAG_CONTAINER)),
            smokeParticles = smokeParticles?.injectItemProperties(itemData.get(SMOKE_PARTICLES_KEY, PersistentDataType.TAG_CONTAINER)),
            transform = transform?.injectItemProperties(itemData.get(TRANSFORM_KEY, PersistentDataType.TAG_CONTAINER)),
        )
    }

    /**
     * Serialize element component data into a Minecraft ItemStack item.
     * Delegates to each individual component, which can set properties
     * in item's meta, lore and persistent data container tree.
     * 
     * This mutates and modifies the input itemMeta, itemLore, and itemData
     * with new properties. So, user must be careful when elements overwrite
     * each other's properties.
     */
    fun toItemData(
        itemMeta: ItemMeta,
        itemLore: ArrayList<String>,
        itemData: PersistentDataContainer,
    ) {
        for ( c in layout ) { // only create data containers for components which exist in layout
            when ( c ) {
                VehicleComponentType.AMMO -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    ammo!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(AMMO_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.AMMO_FIRE_WHEN_LOADED -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    ammoFireWhenLoaded!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(AMMO_FIRE_WHEN_LOADED_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.FUEL -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    fuel!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(FUEL_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.GRAVITY -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    gravity!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(GRAVITY_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.GUN_BARREL -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    gunBarrel!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(GUN_BARREL_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.GUN_TURRET -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    gunTurret!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(GUN_TURRET_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.HEALTH -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    health!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(HEALTH_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    landMovementControls!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(LAND_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    shipMovementControls!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SHIP_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.MODEL -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    model!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(MODEL_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.PARTICLES -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    particles!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(PARTICLES_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SEATS -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    seats!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SEATS_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SEATS_RAYCAST -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    seatsRaycast!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SEATS_RAYCAST_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SMOKE_PARTICLES -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    smokeParticles!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SMOKE_PARTICLES_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.TRANSFORM -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    transform!!.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(TRANSFORM_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                null -> {}
            }
        }
    }

    /**
     * Serialize components set into a json object.
     */
    fun toJson(): JsonObject {
        val json = JsonObject()
        for ( c in this.layout ) {
            // serialize component state in json
            when ( c ) {
                VehicleComponentType.AMMO -> {
                    json.add("ammo", ammo!!.toJson())
                }
                VehicleComponentType.AMMO_FIRE_WHEN_LOADED -> {
                    json.add("ammoFireWhenLoaded", ammoFireWhenLoaded!!.toJson())
                }
                VehicleComponentType.FUEL -> {
                    json.add("fuel", fuel!!.toJson())
                }
                VehicleComponentType.GRAVITY -> {
                    json.add("gravity", gravity!!.toJson())
                }
                VehicleComponentType.GUN_BARREL -> {
                    json.add("gunBarrel", gunBarrel!!.toJson())
                }
                VehicleComponentType.GUN_TURRET -> {
                    json.add("gunTurret", gunTurret!!.toJson())
                }
                VehicleComponentType.HEALTH -> {
                    json.add("health", health!!.toJson())
                }
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> {
                    json.add("landMovementControls", landMovementControls!!.toJson())
                }
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> {
                    json.add("shipMovementControls", shipMovementControls!!.toJson())
                }
                VehicleComponentType.MODEL -> {
                    json.add("model", model!!.toJson())
                }
                VehicleComponentType.PARTICLES -> {
                    json.add("particles", particles!!.toJson())
                }
                VehicleComponentType.SEATS -> {
                    json.add("seats", seats!!.toJson())
                }
                VehicleComponentType.SEATS_RAYCAST -> {
                    json.add("seatsRaycast", seatsRaycast!!.toJson())
                }
                VehicleComponentType.SMOKE_PARTICLES -> {
                    json.add("smokeParticles", smokeParticles!!.toJson())
                }
                VehicleComponentType.TRANSFORM -> {
                    json.add("transform", transform!!.toJson())
                }
                null -> {}
            }
        }
        return json
    }
    
    /**
     * During creation, inject json specific properties and generate
     * a new instance of this component. Used to load serialized vehicle
     * state from stored json objects. Delegates injecting property
     * effects to each individual component.
     *
     * The json object passed into this function should be the one
     * storing the data for the singular element, NOT the object
     * storing the entire vehicle. See the serde file for more details
     * on schema.
     */
    fun injectJsonProperties(
        json: JsonObject,
    ): VehicleComponents {
        return copy(
            ammo = ammo?.injectJsonProperties( json["ammo"]?.asJsonObject ),
            ammoFireWhenLoaded = ammoFireWhenLoaded?.injectJsonProperties( json["ammoFireWhenLoaded"]?.asJsonObject ),
            fuel = fuel?.injectJsonProperties( json["fuel"]?.asJsonObject ),
            gravity = gravity?.injectJsonProperties( json["gravity"]?.asJsonObject ),
            gunBarrel = gunBarrel?.injectJsonProperties( json["gunBarrel"]?.asJsonObject ),
            gunTurret = gunTurret?.injectJsonProperties( json["gunTurret"]?.asJsonObject ),
            health = health?.injectJsonProperties( json["health"]?.asJsonObject ),
            landMovementControls = landMovementControls?.injectJsonProperties( json["landMovementControls"]?.asJsonObject ),
            shipMovementControls = shipMovementControls?.injectJsonProperties( json["shipMovementControls"]?.asJsonObject ),
            model = model?.injectJsonProperties( json["model"]?.asJsonObject ),
            particles = particles?.injectJsonProperties( json["particles"]?.asJsonObject ),
            seats = seats?.injectJsonProperties( json["seats"]?.asJsonObject ),
            seatsRaycast = seatsRaycast?.injectJsonProperties( json["seatsRaycast"]?.asJsonObject ),
            smokeParticles = smokeParticles?.injectJsonProperties( json["smokeParticles"]?.asJsonObject ),
            transform = transform?.injectJsonProperties( json["transform"]?.asJsonObject ),
        )
    }
    
    /**
     * During creation, for each component, send post creation properties,
     * for post-processing after the vehicle has been created. Such as
     * setting up entity to vehicle mappings for armor stands.
     */
    fun afterVehicleCreated(
        xc: XC,
        vehicle: Vehicle,
        element: VehicleElement,
        entityVehicleData: HashMap<UUID, EntityVehicleData>,
    ) {
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.AMMO_FIRE_WHEN_LOADED -> ammoFireWhenLoaded?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.FUEL -> fuel?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.GRAVITY -> gravity?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.GUN_BARREL -> gunBarrel?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.GUN_TURRET -> gunTurret?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.HEALTH -> health?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> shipMovementControls?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.MODEL -> model?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.PARTICLES -> particles?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SEATS -> seats?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SMOKE_PARTICLES -> smokeParticles?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.TRANSFORM -> transform?.afterVehicleCreated(
                    xc=xc,
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                null -> {}
            }
        }
    }

    fun delete(
        xc: XC,
        vehicle: Vehicle,
        element: VehicleElement,
        entityVehicleData: HashMap<UUID, EntityVehicleData>,
        despawn: Boolean,
    ) {
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.AMMO_FIRE_WHEN_LOADED -> ammoFireWhenLoaded?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.FUEL -> fuel?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.GRAVITY -> gravity?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.GUN_BARREL -> gunBarrel?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.GUN_TURRET -> gunTurret?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.HEALTH -> health?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> shipMovementControls?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.MODEL -> model?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.PARTICLES -> particles?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.SEATS -> seats?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.SMOKE_PARTICLES -> smokeParticles?.delete(xc, vehicle, element, entityVehicleData, despawn)
                VehicleComponentType.TRANSFORM -> transform?.delete(xc, vehicle, element, entityVehicleData, despawn)
                null -> {}
            }
        }
    }

    companion object {
        /**
         * Returns an empty vehicle components object.
         */
        public fun empty(): VehicleComponents {
            return VehicleComponents(
                layout = EnumSet.noneOf(VehicleComponentType::class.java),
            )
        }

        /**
         * Parses a vehicle components object from a toml table.
         */
        public fun fromToml(toml: TomlTable, logger: Logger? = null): VehicleComponents {
            // all possible components to be parsed
            var ammo: AmmoComponent? = null
            var ammoFireWhenLoaded: AmmoFireWhenLoadedComponent? = null
            var fuel: FuelComponent? = null
            var gravity: GravityComponent? = null
            var gunBarrel: GunBarrelComponent? = null
            var gunTurret: GunTurretComponent? = null
            var health: HealthComponent? = null
            var landMovementControls: LandMovementControlsComponent? = null
            var shipMovementControls: ShipMovementControlsComponent? = null
            var model: ModelComponent? = null
            var particles: ParticlesComponent? = null
            var seats: SeatsComponent? = null
            var seatsRaycast: SeatsRaycastComponent? = null
            var smokeParticles: SmokeParticlesComponent? = null
            var transform: TransformComponent? = null

            // parse components from matching keys in toml
            val layout = EnumSet.noneOf(VehicleComponentType::class.java)
            val keys = toml.keySet()
            for ( k in keys ) {
                when ( k ) {
                    "name", "parent" -> continue
                    "ammo" -> {
                        layout.add(VehicleComponentType.AMMO)
                        ammo = AmmoComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "ammo_fire_when_loaded" -> {
                        layout.add(VehicleComponentType.AMMO_FIRE_WHEN_LOADED)
                        ammoFireWhenLoaded = AmmoFireWhenLoadedComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "fuel" -> {
                        layout.add(VehicleComponentType.FUEL)
                        fuel = FuelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "gravity" -> {
                        layout.add(VehicleComponentType.GRAVITY)
                        gravity = GravityComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "gun_barrel" -> {
                        layout.add(VehicleComponentType.GUN_BARREL)
                        gunBarrel = GunBarrelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "gun_turret" -> {
                        layout.add(VehicleComponentType.GUN_TURRET)
                        gunTurret = GunTurretComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "health" -> {
                        layout.add(VehicleComponentType.HEALTH)
                        health = HealthComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "land_movement_controls" -> {
                        layout.add(VehicleComponentType.LAND_MOVEMENT_CONTROLS)
                        landMovementControls = LandMovementControlsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "ship_movement_controls" -> {
                        layout.add(VehicleComponentType.SHIP_MOVEMENT_CONTROLS)
                        shipMovementControls = ShipMovementControlsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "model" -> {
                        layout.add(VehicleComponentType.MODEL)
                        model = ModelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "particles" -> {
                        layout.add(VehicleComponentType.PARTICLES)
                        particles = ParticlesComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "seats" -> {
                        layout.add(VehicleComponentType.SEATS)
                        seats = SeatsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "seats_raycast" -> {
                        layout.add(VehicleComponentType.SEATS_RAYCAST)
                        seatsRaycast = SeatsRaycastComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "smoke_particles" -> {
                        layout.add(VehicleComponentType.SMOKE_PARTICLES)
                        smokeParticles = SmokeParticlesComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "transform" -> {
                        layout.add(VehicleComponentType.TRANSFORM)
                        transform = TransformComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    else -> logger?.warning("Unknown key in vehicle element: $k")
                }
            }
            
            return VehicleComponents(
                layout,
                ammo,
                ammoFireWhenLoaded,
                fuel,
                gravity,
                gunBarrel,
                gunTurret,
                health,
                landMovementControls,
                shipMovementControls,
                model,
                particles,
                seats,
                seatsRaycast,
                smokeParticles,
                transform,
            )
        }
    }
}

/**
 * Archetype, contains set of possible component storages which store
 * actual vehicle component instances. Components storages are sparse sets.
 * Archetype implements a packed struct-of-arrays format for fast iteration.
 * Element Id used to lookup an instance's packed array index.
 */
public class ArchetypeStorage(
    val layout: EnumSet<VehicleComponentType>,
    val maxElements: Int,
) {
    public var size: Int = 0
        internal set

    // sparse lookup from element id => element components dense index
    // (note vehicle element id is just a typealias for int)
    private val lookup: IntArray = IntArray(maxElements, { _ -> INVALID_VEHICLE_ELEMENT_ID })

    // reverse lookup from dense array index => vehicle element id
    // only internal cuz iterator classes need it
    internal val elements: IntArray = IntArray(maxElements) { _ -> INVALID_VEHICLE_ELEMENT_ID }

    // dense packed components storages
    // only components in layout will be non-null
    internal val ammo: ArrayList<AmmoComponent>? = if ( layout.contains(VehicleComponentType.AMMO) ) ArrayList() else null
    internal val ammoFireWhenLoaded: ArrayList<AmmoFireWhenLoadedComponent>? = if ( layout.contains(VehicleComponentType.AMMO_FIRE_WHEN_LOADED) ) ArrayList() else null
    internal val fuel: ArrayList<FuelComponent>? = if ( layout.contains(VehicleComponentType.FUEL) ) ArrayList() else null
    internal val gravity: ArrayList<GravityComponent>? = if ( layout.contains(VehicleComponentType.GRAVITY) ) ArrayList() else null
    internal val gunBarrel: ArrayList<GunBarrelComponent>? = if ( layout.contains(VehicleComponentType.GUN_BARREL) ) ArrayList() else null
    internal val gunTurret: ArrayList<GunTurretComponent>? = if ( layout.contains(VehicleComponentType.GUN_TURRET) ) ArrayList() else null
    internal val health: ArrayList<HealthComponent>? = if ( layout.contains(VehicleComponentType.HEALTH) ) ArrayList() else null
    internal val landMovementControls: ArrayList<LandMovementControlsComponent>? = if ( layout.contains(VehicleComponentType.LAND_MOVEMENT_CONTROLS) ) ArrayList() else null
    internal val shipMovementControls: ArrayList<ShipMovementControlsComponent>? = if ( layout.contains(VehicleComponentType.SHIP_MOVEMENT_CONTROLS) ) ArrayList() else null
    internal val model: ArrayList<ModelComponent>? = if ( layout.contains(VehicleComponentType.MODEL) ) ArrayList() else null
    internal val particles: ArrayList<ParticlesComponent>? = if ( layout.contains(VehicleComponentType.PARTICLES) ) ArrayList() else null
    internal val seats: ArrayList<SeatsComponent>? = if ( layout.contains(VehicleComponentType.SEATS) ) ArrayList() else null
    internal val seatsRaycast: ArrayList<SeatsRaycastComponent>? = if ( layout.contains(VehicleComponentType.SEATS_RAYCAST) ) ArrayList() else null
    internal val smokeParticles: ArrayList<SmokeParticlesComponent>? = if ( layout.contains(VehicleComponentType.SMOKE_PARTICLES) ) ArrayList() else null
    internal val transform: ArrayList<TransformComponent>? = if ( layout.contains(VehicleComponentType.TRANSFORM) ) ArrayList() else null

    // public getter "view"s: only expose immutable List interface
    public val ammoView: List<AmmoComponent>?
        get() = this.ammo
    public val ammoFireWhenLoadedView: List<AmmoFireWhenLoadedComponent>?
        get() = this.ammoFireWhenLoaded
    public val fuelView: List<FuelComponent>?
        get() = this.fuel
    public val gravityView: List<GravityComponent>?
        get() = this.gravity
    public val gunBarrelView: List<GunBarrelComponent>?
        get() = this.gunBarrel
    public val gunTurretView: List<GunTurretComponent>?
        get() = this.gunTurret
    public val healthView: List<HealthComponent>?
        get() = this.health
    public val landMovementControlsView: List<LandMovementControlsComponent>?
        get() = this.landMovementControls
    public val shipMovementControlsView: List<ShipMovementControlsComponent>?
        get() = this.shipMovementControls
    public val modelView: List<ModelComponent>?
        get() = this.model
    public val particlesView: List<ParticlesComponent>?
        get() = this.particles
    public val seatsView: List<SeatsComponent>?
        get() = this.seats
    public val seatsRaycastView: List<SeatsRaycastComponent>?
        get() = this.seatsRaycast
    public val smokeParticlesView: List<SmokeParticlesComponent>?
        get() = this.smokeParticles
    public val transformView: List<TransformComponent>?
        get() = this.transform

    /**
     * Get component by id. Returns null if component is not in archetype.
     */
    inline fun <reified T: VehicleComponent<T>> getComponent(id: VehicleElementId): T? {
        val denseIndex = this.getDenseIndex(id)
        if ( denseIndex == INVALID_VEHICLE_ELEMENT_ID ) {
            return null
        }
        
        return when ( T::class ) {
            AmmoComponent::class -> this.ammoView?.get(denseIndex) as T
            AmmoFireWhenLoadedComponent::class -> this.ammoFireWhenLoadedView?.get(denseIndex) as T
            FuelComponent::class -> this.fuelView?.get(denseIndex) as T
            GravityComponent::class -> this.gravityView?.get(denseIndex) as T
            GunBarrelComponent::class -> this.gunBarrelView?.get(denseIndex) as T
            GunTurretComponent::class -> this.gunTurretView?.get(denseIndex) as T
            HealthComponent::class -> this.healthView?.get(denseIndex) as T
            LandMovementControlsComponent::class -> this.landMovementControlsView?.get(denseIndex) as T
            ShipMovementControlsComponent::class -> this.shipMovementControlsView?.get(denseIndex) as T
            ModelComponent::class -> this.modelView?.get(denseIndex) as T
            ParticlesComponent::class -> this.particlesView?.get(denseIndex) as T
            SeatsComponent::class -> this.seatsView?.get(denseIndex) as T
            SeatsRaycastComponent::class -> this.seatsRaycastView?.get(denseIndex) as T
            SmokeParticlesComponent::class -> this.smokeParticlesView?.get(denseIndex) as T
            TransformComponent::class -> this.transformView?.get(denseIndex) as T
            else -> throw Exception("Unknown component type.")
        }
    }

    /**
     * Get dense index from id.
     */
    public fun getDenseIndex(id: VehicleElementId): Int {
        return this.lookup[id]
    }

    /**
     * Insert components into the archetype. Returns invalid element id
     * if insertion failed.
     */
    public fun insert(
        id: VehicleElementId,
        components: VehicleComponents,
    ): VehicleElementId {
        if ( this.layout != components.layout ) {
            return INVALID_VEHICLE_ELEMENT_ID
        }

        // if id > maxElements, then we can't insert
        if ( id >= maxElements || size >= maxElements ) {
            return INVALID_VEHICLE_ELEMENT_ID
        }

        // check if id is already in use
        if ( lookup[id] != INVALID_VEHICLE_ELEMENT_ID ) {
            return INVALID_VEHICLE_ELEMENT_ID
        }

        // get dense index
        val denseIndex = size
        size += 1
        
        // set sparse <-> dense element mappings
        lookup[id] = denseIndex
        elements[denseIndex] = id

        // push components into storages
        for ( c in components.layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> {
                    this.ammo?.pushAtDenseIndex(denseIndex, components.ammo!!)
                }
                
                VehicleComponentType.AMMO_FIRE_WHEN_LOADED -> {
                    this.ammoFireWhenLoaded?.pushAtDenseIndex(denseIndex, components.ammoFireWhenLoaded!!)
                }
                
                VehicleComponentType.FUEL -> {
                    this.fuel?.pushAtDenseIndex(denseIndex, components.fuel!!)
                }
                
                VehicleComponentType.GRAVITY -> {
                    this.gravity?.pushAtDenseIndex(denseIndex, components.gravity!!)
                }
                
                VehicleComponentType.GUN_BARREL -> {
                    this.gunBarrel?.pushAtDenseIndex(denseIndex, components.gunBarrel!!)
                }
                
                VehicleComponentType.GUN_TURRET -> {
                    this.gunTurret?.pushAtDenseIndex(denseIndex, components.gunTurret!!)
                }
                
                VehicleComponentType.HEALTH -> {
                    this.health?.pushAtDenseIndex(denseIndex, components.health!!)
                }
                
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> {
                    this.landMovementControls?.pushAtDenseIndex(denseIndex, components.landMovementControls!!)
                }
                
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> {
                    this.shipMovementControls?.pushAtDenseIndex(denseIndex, components.shipMovementControls!!)
                }
                
                VehicleComponentType.MODEL -> {
                    this.model?.pushAtDenseIndex(denseIndex, components.model!!)
                }
                
                VehicleComponentType.PARTICLES -> {
                    this.particles?.pushAtDenseIndex(denseIndex, components.particles!!)
                }
                
                VehicleComponentType.SEATS -> {
                    this.seats?.pushAtDenseIndex(denseIndex, components.seats!!)
                }
                
                VehicleComponentType.SEATS_RAYCAST -> {
                    this.seatsRaycast?.pushAtDenseIndex(denseIndex, components.seatsRaycast!!)
                }
                
                VehicleComponentType.SMOKE_PARTICLES -> {
                    this.smokeParticles?.pushAtDenseIndex(denseIndex, components.smokeParticles!!)
                }
                
                VehicleComponentType.TRANSFORM -> {
                    this.transform?.pushAtDenseIndex(denseIndex, components.transform!!)
                }
                
                null -> {}
            }
        }

        return id
    }

    /**
     * Frees an element from the archetype. Removes all components
     * and frees element id.
     */
    public fun free(id: VehicleElementId, logger: Logger? = null) {
        // validate id is inside storage
        if ( id < 0 || id >= maxElements ) {
            logger?.severe("Archetype.remove() invalid element id out of range: $id")
            return
        }

        // validate id inside dense array == id
        val denseIndex = lookup[id]
        if ( denseIndex == INVALID_VEHICLE_ELEMENT_ID || elements[denseIndex] != id ) {
            logger?.severe("Archetype.remove() element id not in array: $id")
            return
        }

        // swap values in dense array with last element and update lookup index
        // Note: to handle case that denseIndex == lastIndex, the operation order
        // below deliberately sets indices to INVALID_VEHICLE_ELEMENT_ID as
        // the last operation 
        val lastIndex = size - 1
        val swappedId = elements[lastIndex]
        elements[denseIndex] = swappedId
        elements[lastIndex] = INVALID_VEHICLE_ELEMENT_ID
        lookup[swappedId] = denseIndex
        lookup[id] = INVALID_VEHICLE_ELEMENT_ID

        // swap remove elements in component arrays
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.swapRemove(denseIndex)
                VehicleComponentType.AMMO_FIRE_WHEN_LOADED -> ammoFireWhenLoaded?.swapRemove(denseIndex)
                VehicleComponentType.FUEL -> fuel?.swapRemove(denseIndex)
                VehicleComponentType.GRAVITY -> gravity?.swapRemove(denseIndex)
                VehicleComponentType.GUN_BARREL -> gunBarrel?.swapRemove(denseIndex)
                VehicleComponentType.GUN_TURRET -> gunTurret?.swapRemove(denseIndex)
                VehicleComponentType.HEALTH -> health?.swapRemove(denseIndex)
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.swapRemove(denseIndex)
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> shipMovementControls?.swapRemove(denseIndex)
                VehicleComponentType.MODEL -> model?.swapRemove(denseIndex)
                VehicleComponentType.PARTICLES -> particles?.swapRemove(denseIndex)
                VehicleComponentType.SEATS -> seats?.swapRemove(denseIndex)
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.swapRemove(denseIndex)
                VehicleComponentType.SMOKE_PARTICLES -> smokeParticles?.swapRemove(denseIndex)
                VehicleComponentType.TRANSFORM -> transform?.swapRemove(denseIndex)
                null -> {}
            }
        }
        
        // decrement archetype size
        size -= 1
    }
    
    /**
     * Remove all elements from archetype.
     */
    public fun clear() {
        size = 0

        // reset lookup
        for ( i in 0 until maxElements ) {
            lookup[i] = INVALID_VEHICLE_ELEMENT_ID
            elements[i] = INVALID_VEHICLE_ELEMENT_ID
        }
        ammo?.clear()
        ammoFireWhenLoaded?.clear()
        fuel?.clear()
        gravity?.clear()
        gunBarrel?.clear()
        gunTurret?.clear()
        health?.clear()
        landMovementControls?.clear()
        shipMovementControls?.clear()
        model?.clear()
        particles?.clear()
        seats?.clear()
        seatsRaycast?.clear()
        smokeParticles?.clear()
        transform?.clear()
    }

    public companion object {
        /**
         * Higher order function that returns a function that gets a
         * Vehicle component type's storage within the archetype.
         * Needed to allows compile-time access to a type's component
         * storage in the archetype. Used for generic tuple iterators.
         * 
         * Internally does unsafe cast, since storages may be null.
         * Client caller must make sure archetypes have the storages.
         * 
         * Note: this may be generating a new lambda object at each call.
         * May want to cache the lambda object, or hard-code each function
         * in future.
         */
        @Suppress("UNCHECKED_CAST")
        public inline fun <reified T> accessor(): (ArchetypeStorage) -> List<T> {
            return when ( T::class ) {
                AmmoComponent::class -> { archetype -> archetype.ammoView as List<T> }
                AmmoFireWhenLoadedComponent::class -> { archetype -> archetype.ammoFireWhenLoadedView as List<T> }
                FuelComponent::class -> { archetype -> archetype.fuelView as List<T> }
                GravityComponent::class -> { archetype -> archetype.gravityView as List<T> }
                GunBarrelComponent::class -> { archetype -> archetype.gunBarrelView as List<T> }
                GunTurretComponent::class -> { archetype -> archetype.gunTurretView as List<T> }
                HealthComponent::class -> { archetype -> archetype.healthView as List<T> }
                LandMovementControlsComponent::class -> { archetype -> archetype.landMovementControlsView as List<T> }
                ShipMovementControlsComponent::class -> { archetype -> archetype.shipMovementControlsView as List<T> }
                ModelComponent::class -> { archetype -> archetype.modelView as List<T> }
                ParticlesComponent::class -> { archetype -> archetype.particlesView as List<T> }
                SeatsComponent::class -> { archetype -> archetype.seatsView as List<T> }
                SeatsRaycastComponent::class -> { archetype -> archetype.seatsRaycastView as List<T> }
                SmokeParticlesComponent::class -> { archetype -> archetype.smokeParticlesView as List<T> }
                TransformComponent::class -> { archetype -> archetype.transformView as List<T> }
                else -> throw Exception("Unknown component type")
            }
        }
    }
}