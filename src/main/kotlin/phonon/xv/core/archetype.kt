/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Archetype style ECS data storage core.
 * 
 * Contains vehicle component enum + interface and archetype storage.
 * 
 * Since component set is finite, just hard-code optional component
 * storages in each archetype. Engine must ensure we only access
 * valid storages in the archetype
 * 
 * See references:
 * https://github.com/amethyst/legion/blob/master/src/internals/storage/archetype.rs
 */

package phonon.xv.core

import java.util.EnumSet
import phonon.xv.core.INVALID_ID
import phonon.xv.component.*


/**
 * Note: keep in alphabetical order.
 */
public enum class VehicleComponentType {
    FUEL,
    GUN_TURRET,
    HEALTH,
    LAND_MOVEMENT_CONTROLS,
    MODEL,
    SEAT,
    TRANSFORM,
    ;

    public companion object {
        /**
         * Converts from compile-time generic vehicle component type. 
         */
        public inline fun <reified T: VehicleComponent> from(): VehicleComponentType {
            return when ( T::class ) {
                FuelComponent::class -> VehicleComponentType.FUEL
                GunTurretComponent::class -> VehicleComponentType.GUN_TURRET
                HealthComponent::class -> VehicleComponentType.HEALTH
                LandMovementControlsComponent::class -> VehicleComponentType.LAND_MOVEMENT_CONTROLS
                ModelComponent::class -> VehicleComponentType.MODEL
                SeatComponent::class -> VehicleComponentType.SEAT
                TransformComponent::class -> VehicleComponentType.TRANSFORM
                else -> throw Exception("Unknown component type")
            }
        }
    }
}

/**
 * Component interface
 */
public interface VehicleComponent {

}


/**
 * Archetype, contains set of possible component storages.
 * Components stored in packed struct-of-arrays format.
 * Element Id used to lookup packed index.
 */
public class ArchetypeStorage(
    val layout: EnumSet<VehicleComponentType>,
    val maxElements: Int,
) {
    public var size: Int = 0
        // private set // TODO: when implemented, outside should never change size
    
    // map from vehicle element id => element's dense array index
    // TODO: replace with specialized Densemap
    public val lookup: HashMap<VehicleElementId, Int> = HashMap()

    // dense packed element ids
    public val elements: IntArray = IntArray(maxElements, {_ -> INVALID_ID})

    // dense packed components
    // only components in layout will be non-null
    public val fuel: ArrayList<FuelComponent>? = if ( layout.contains(VehicleComponentType.FUEL) ) ArrayList() else null
    public val gunTurret: ArrayList<GunTurretComponent>? = if ( layout.contains(VehicleComponentType.GUN_TURRET) ) ArrayList() else null
    public val health: ArrayList<HealthComponent>? = if ( layout.contains(VehicleComponentType.HEALTH) ) ArrayList() else null
    public val landMovementControls: ArrayList<LandMovementControlsComponent>? = if ( layout.contains(VehicleComponentType.LAND_MOVEMENT_CONTROLS) ) ArrayList() else null
    public val model: ArrayList<ModelComponent>? = if ( layout.contains(VehicleComponentType.MODEL) ) ArrayList() else null
    public val seat: ArrayList<SeatComponent>? = if ( layout.contains(VehicleComponentType.SEAT) ) ArrayList() else null
    public val transform: ArrayList<TransformComponent>? = if ( layout.contains(VehicleComponentType.TRANSFORM) ) ArrayList() else null
    

    public companion object {
        /**
         * Higher order function that returns a function that gets a
         * Vehicle component type's storage within the archetype.
         * Needed to allows compile-time access to a type's component
         * storage in the archetype. Used for generic tuple iterators.
         * 
         * Internally does unsafe cast, since storages may be null.
         * Client caller must make sure archetypes have the storages.
         * 
         * Note: this may be generating a new lambda object at each call.
         * May want to cache the lambda object, or hard-code each function
         * in future.
         */
        @Suppress("UNCHECKED_CAST")
        public inline fun <reified T> accessor(): (ArchetypeStorage) -> ArrayList<T> {
            return when ( T::class ) {
                FuelComponent::class -> { archetype -> archetype.fuel as ArrayList<T> }
                GunTurretComponent::class -> { archetype -> archetype.gunTurret as ArrayList<T> }
                HealthComponent::class -> { archetype -> archetype.health as ArrayList<T> }
                LandMovementControlsComponent::class -> { archetype -> archetype.landMovementControls as ArrayList<T> }
                ModelComponent::class -> { archetype -> archetype.model as ArrayList<T> }
                SeatComponent::class -> { archetype -> archetype.seat as ArrayList<T> }
                TransformComponent::class -> { archetype -> archetype.transform as ArrayList<T> }
                else -> throw Exception("Unknown component type")
            }
        }
    }
}