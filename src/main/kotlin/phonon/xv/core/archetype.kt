/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Archetype style ECS data storage core.
 * 
 * Contains vehicle component enum + interface and archetype storage.
 * 
 * Since component set is finite, just hard-code optional component
 * storages in each archetype. Engine must ensure we only access
 * valid storages in the archetype
 * 
 * See references:
 * https://github.com/amethyst/legion/blob/master/src/internals/storage/archetype.rs
 */

package phonon.xv.core

import java.util.logging.Logger
import java.util.EnumSet
import com.google.gson.JsonObject
import phonon.xv.component.*
import java.util.Stack

// Const indicating invalid dense array index
public const val INVALID_ELEMENT_ID: Int = -1

/**
 * Helper function to push an element into a dense array.
 * Validates that the index is at the end of the array.
 */
private fun <T> ArrayList<T>.pushAtDenseIndex(index: Int, value: T) {
    val storageSize = this.size
    if ( storageSize == index ) {
        this.add(value)
    } else {
        throw IllegalStateException("Archetype storage attempted to insert an element at a dense index larger than current size: ${index} (size = ${storageSize})")
    }
}

/**
 * Helper function to remove an element by swapping it with the last 
 * element in the array.
 */
private fun <T> ArrayList<T>.swapRemove(index: Int) {
    val storageSize = this.size
    if ( storageSize == 1 ) {
        this.removeAt(0)
    } else {
        // swap with last element
        val last = this[storageSize - 1]
        this[index] = last
        this.removeAt(storageSize - 1)
    }
}

/**
 * Note: keep in alphabetical order.
 */
public enum class VehicleComponentType {
    AMMO,
    FUEL,
    GUN_BARREL,
    GUN_TURRET,
    HEALTH,
    LAND_MOVEMENT_CONTROLS,
    SHIP_MOVEMENT_CONTROLS,
    MODEL,
    SEATS,
    SEATS_RAYCAST,
    SPAWN,
    TRANSFORM,
    ;

    public companion object {
        /**
         * Converts from compile-time generic vehicle component type. 
         */
        public inline fun <reified T: VehicleComponent<T>> from(): VehicleComponentType {
            return when ( T::class ) {
                AmmoComponent::class -> VehicleComponentType.AMMO
                FuelComponent::class -> VehicleComponentType.FUEL
                GunBarrelComponent::class -> VehicleComponentType.GUN_BARREL
                GunTurretComponent::class -> VehicleComponentType.GUN_TURRET
                HealthComponent::class -> VehicleComponentType.HEALTH
                LandMovementControlsComponent::class -> VehicleComponentType.LAND_MOVEMENT_CONTROLS
                ShipMovementControlsComponent::class -> VehicleComponentType.SHIP_MOVEMENT_CONTROLS
                ModelComponent::class -> VehicleComponentType.MODEL
                SeatsComponent::class -> VehicleComponentType.SEATS
                SeatsRaycastComponent::class -> VehicleComponentType.SEATS_RAYCAST
                SpawnComponent::class -> VehicleComponentType.SPAWN
                TransformComponent::class -> VehicleComponentType.TRANSFORM
                else -> throw Exception("Unknown component type")
            }
        }
    }
}

/**
 * Archetype, contains set of possible component storages.
 * Components stored in packed struct-of-arrays format.
 * Element Id used to lookup packed index.
 */
public class ArchetypeStorage(
    val layout: EnumSet<VehicleComponentType>,
    val maxElements: Int,
) {
    public var size: Int = 0
        internal set

    // sparse lookup from id => element
    // (note vehicle element id is just a typealias for int)
    // Internally lookup also stores a linked list of next free element,
    // so initialize with each element pointing to the next element
    // (e.g. next free element is the next element in the array)
    private val lookup: IntArray = IntArray(maxElements, { i -> i + 1 })

    // reverse lookup from dense array index => vehicle element id
    // only internal cuz iterator classes need it
    internal val elements: IntArray = IntArray(maxElements) { _ -> INVALID_ELEMENT_ID }

    // lookup implicit linked list head
    internal var nextFree: Int = 0

    // dense packed components storages
    // only components in layout will be non-null
    internal val ammo: ArrayList<AmmoComponent>? = if ( layout.contains(VehicleComponentType.AMMO) ) ArrayList() else null
    internal val fuel: ArrayList<FuelComponent>? = if ( layout.contains(VehicleComponentType.FUEL) ) ArrayList() else null
    internal val gunBarrel: ArrayList<GunBarrelComponent>? = if ( layout.contains(VehicleComponentType.GUN_BARREL) ) ArrayList() else null
    internal val gunTurret: ArrayList<GunTurretComponent>? = if ( layout.contains(VehicleComponentType.GUN_TURRET) ) ArrayList() else null
    internal val health: ArrayList<HealthComponent>? = if ( layout.contains(VehicleComponentType.HEALTH) ) ArrayList() else null
    internal val landMovementControls: ArrayList<LandMovementControlsComponent>? = if ( layout.contains(VehicleComponentType.LAND_MOVEMENT_CONTROLS) ) ArrayList() else null
    internal val shipMovementControls: ArrayList<ShipMovementControlsComponent>? = if ( layout.contains(VehicleComponentType.SHIP_MOVEMENT_CONTROLS) ) ArrayList() else null
    internal val model: ArrayList<ModelComponent>? = if ( layout.contains(VehicleComponentType.MODEL) ) ArrayList() else null
    internal val seats: ArrayList<SeatsComponent>? = if ( layout.contains(VehicleComponentType.SEATS) ) ArrayList() else null
    internal val seatsRaycast: ArrayList<SeatsRaycastComponent>? = if ( layout.contains(VehicleComponentType.SEATS_RAYCAST) ) ArrayList() else null
    internal val spawn: ArrayList<SpawnComponent>? = if ( layout.contains(VehicleComponentType.SPAWN) ) ArrayList() else null
    internal val transform: ArrayList<TransformComponent>? = if ( layout.contains(VehicleComponentType.TRANSFORM) ) ArrayList() else null

    // public getter "view"s: only expose immutable List interface
    public val ammoView: List<AmmoComponent>?
        get() = this.ammo
    public val fuelView: List<FuelComponent>?
        get() = this.fuel
    public val gunBarrelView: List<GunBarrelComponent>?
        get() = this.gunBarrel
    public val gunTurretView: List<GunTurretComponent>?
        get() = this.gunTurret
    public val healthView: List<HealthComponent>?
        get() = this.health
    public val landMovementControlsView: List<LandMovementControlsComponent>?
        get() = this.landMovementControls
    public val shipMovementControlsView: List<ShipMovementControlsComponent>?
        get() = this.shipMovementControls
    public val modelView: List<ModelComponent>?
        get() = this.model
    public val seatsView: List<SeatsComponent>?
        get() = this.seats
    public val seatsRaycastView: List<SeatsRaycastComponent>?
        get() = this.seatsRaycast
    public val spawnView: List<SpawnComponent>?
        get() = this.spawn
    public val transformView: List<TransformComponent>?
        get() = this.transform

    /**
     * Get component by id. Returns null if component is not in archetype.
     */
    inline fun <reified T: VehicleComponent<T>> getComponent(id: VehicleElementId): T? {
        val denseIndex = this.getDenseIndex(id)
        if ( denseIndex == INVALID_ELEMENT_ID ) {
            return null
        }
        
        return when ( T::class ) {
            AmmoComponent::class -> this.ammoView?.get(denseIndex) as T
            FuelComponent::class -> this.fuelView?.get(denseIndex) as T
            GunBarrelComponent::class -> this.gunBarrelView?.get(denseIndex) as T
            GunTurretComponent::class -> this.gunTurretView?.get(denseIndex) as T
            HealthComponent::class -> this.healthView?.get(denseIndex) as T
            LandMovementControlsComponent::class -> this.landMovementControlsView?.get(denseIndex) as T
            ShipMovementControlsComponent::class -> this.shipMovementControlsView?.get(denseIndex) as T
            ModelComponent::class -> this.modelView?.get(denseIndex) as T
            SeatsComponent::class -> this.seatsView?.get(denseIndex) as T
            SeatsRaycastComponent::class -> this.seatsRaycastView?.get(denseIndex) as T
            SpawnComponent::class -> this.spawnView?.get(denseIndex) as T
            TransformComponent::class -> this.transformView?.get(denseIndex) as T
            else -> throw Exception("Unknown component type.")
        }
    }

    /**
     * Get dense index from id.
     */
    public fun getDenseIndex(id: VehicleElementId): Int {
        return this.lookup[id]
    }

    /**
     * Insert a prototype into the archetype. Returns a new element id
     * corresponding to its lookup index in the archetype.
     * Returns null if layout does not match or if the archetype is full.
     */
    public fun insert(
        prototype: VehicleElementPrototype,
    ): VehicleElementId? {
        if ( this.layout != prototype.layout ) {
            return null
        }

        // try to allocate a new element id (lookup id)
        if ( size >= maxElements ) {
            return null
        }
        // new id is head of linked list
        val id = nextFree
        // set new head of implicit linked list
        nextFree = lookup[nextFree]
        // get dense index
        val denseIndex = size
        size += 1
        
        // set sparse <-> dense element mappings
        lookup[id] = denseIndex
        elements[denseIndex] = id

        // push prototype components into storages
        for ( c in prototype.layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> {
                    this.ammo?.pushAtDenseIndex(denseIndex, prototype.ammo!!)
                }
                
                VehicleComponentType.FUEL -> {
                    this.fuel?.pushAtDenseIndex(denseIndex, prototype.fuel!!)
                }
                
                VehicleComponentType.GUN_BARREL -> {
                    this.gunBarrel?.pushAtDenseIndex(denseIndex, prototype.gunBarrel!!)
                }
                
                VehicleComponentType.GUN_TURRET -> {
                    this.gunTurret?.pushAtDenseIndex(denseIndex, prototype.gunTurret!!)
                }
                
                VehicleComponentType.HEALTH -> {
                    this.health?.pushAtDenseIndex(denseIndex, prototype.health!!)
                }
                
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> {
                    this.landMovementControls?.pushAtDenseIndex(denseIndex, prototype.landMovementControls!!)
                }
                
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> {
                    this.shipMovementControls?.pushAtDenseIndex(denseIndex, prototype.shipMovementControls!!)
                }
                
                VehicleComponentType.MODEL -> {
                    this.model?.pushAtDenseIndex(denseIndex, prototype.model!!)
                }
                
                VehicleComponentType.SEATS -> {
                    this.seats?.pushAtDenseIndex(denseIndex, prototype.seats!!)
                }
                
                VehicleComponentType.SEATS_RAYCAST -> {
                    this.seatsRaycast?.pushAtDenseIndex(denseIndex, prototype.seatsRaycast!!)
                }
                
                VehicleComponentType.SPAWN -> {
                    this.spawn?.pushAtDenseIndex(denseIndex, prototype.spawn!!)
                }
                
                VehicleComponentType.TRANSFORM -> {
                    this.transform?.pushAtDenseIndex(denseIndex, prototype.transform!!)
                }
                
                null -> {}
            }
        }

        return id
    }

    /**
     * Frees an element from the archetype. Removes all components
     * and frees element id.
     */
    public fun free(id: VehicleElementId, logger: Logger? = null) {
        // validate id is inside storage
        if ( id < 0 || id >= maxElements ) {
            logger?.severe("Archetype.remove() invalid element id: $id")
            return
        }

        // validate id inside dense array == id
        val denseIndex = lookup[id]
        if ( elements[denseIndex] != id ) {
            logger?.severe("Archetype.remove() element id not in array: $id")
            return
        }

        // swap values in dense array w/ last elt
        val swappedDenseIndex = size - 1
        val swappedId = elements[swappedDenseIndex]
        elements[denseIndex] = swappedId
        elements[swappedDenseIndex] = INVALID_ELEMENT_ID

        // update lookup and implicit list head
        lookup[id] = nextFree
        nextFree = id
        lookup[swappedId] = denseIndex

        // swap remove elements in component arrays
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.swapRemove(denseIndex)
                VehicleComponentType.FUEL -> fuel?.swapRemove(denseIndex)
                VehicleComponentType.GUN_BARREL -> gunBarrel?.swapRemove(denseIndex)
                VehicleComponentType.GUN_TURRET -> gunTurret?.swapRemove(denseIndex)
                VehicleComponentType.HEALTH -> health?.swapRemove(denseIndex)
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.swapRemove(denseIndex)
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> shipMovementControls?.swapRemove(denseIndex)
                VehicleComponentType.MODEL -> model?.swapRemove(denseIndex)
                VehicleComponentType.SEATS -> seats?.swapRemove(denseIndex)
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.swapRemove(denseIndex)
                VehicleComponentType.SPAWN -> spawn?.swapRemove(denseIndex)
                VehicleComponentType.TRANSFORM -> transform?.swapRemove(denseIndex)
                null -> {}
            }
        }
        
        // decrement archetype size
        size -= 1
    }
    
    /**
     * Remove all elements from archetype.
     */
    public fun clear() {
        size = 0

        // reset lookup implicit linked
        for ( i in 0 until maxElements ) {
            lookup[i] = i + 1
            elements[i] = INVALID_ELEMENT_ID
        }
        nextFree = 0
        ammo?.clear()
        fuel?.clear()
        gunBarrel?.clear()
        gunTurret?.clear()
        health?.clear()
        landMovementControls?.clear()
        shipMovementControls?.clear()
        model?.clear()
        seats?.clear()
        seatsRaycast?.clear()
        spawn?.clear()
        transform?.clear()
    }

    public companion object {
        /**
         * Higher order function that returns a function that gets a
         * Vehicle component type's storage within the archetype.
         * Needed to allows compile-time access to a type's component
         * storage in the archetype. Used for generic tuple iterators.
         * 
         * Internally does unsafe cast, since storages may be null.
         * Client caller must make sure archetypes have the storages.
         * 
         * Note: this may be generating a new lambda object at each call.
         * May want to cache the lambda object, or hard-code each function
         * in future.
         */
        @Suppress("UNCHECKED_CAST")
        public inline fun <reified T> accessor(): (ArchetypeStorage) -> List<T> {
            return when ( T::class ) {
                AmmoComponent::class -> { archetype -> archetype.ammoView as List<T> }
                FuelComponent::class -> { archetype -> archetype.fuelView as List<T> }
                GunBarrelComponent::class -> { archetype -> archetype.gunBarrelView as List<T> }
                GunTurretComponent::class -> { archetype -> archetype.gunTurretView as List<T> }
                HealthComponent::class -> { archetype -> archetype.healthView as List<T> }
                LandMovementControlsComponent::class -> { archetype -> archetype.landMovementControlsView as List<T> }
                ShipMovementControlsComponent::class -> { archetype -> archetype.shipMovementControlsView as List<T> }
                ModelComponent::class -> { archetype -> archetype.modelView as List<T> }
                SeatsComponent::class -> { archetype -> archetype.seatsView as List<T> }
                SeatsRaycastComponent::class -> { archetype -> archetype.seatsRaycastView as List<T> }
                SpawnComponent::class -> { archetype -> archetype.spawnView as List<T> }
                TransformComponent::class -> { archetype -> archetype.transformView as List<T> }
                else -> throw Exception("Unknown component type")
            }
        }
    }
}