/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Archetype style ECS data storage core.
 * 
 * Contains vehicle component enum + interface and archetype storage.
 * 
 * Since component set is finite, just hard-code optional component
 * storages in each archetype. Engine must ensure we only access
 * valid storages in the archetype
 * 
 * See references:
 * https://github.com/amethyst/legion/blob/master/src/internals/storage/archetype.rs
 */

package phonon.xv.core

import java.util.UUID
import java.util.logging.Logger
import java.util.EnumSet
import com.google.gson.JsonObject
import org.tomlj.Toml
import org.tomlj.TomlTable
import org.bukkit.Location
import org.bukkit.NamespacedKey
import org.bukkit.entity.Player
import org.bukkit.inventory.ItemStack
import org.bukkit.inventory.meta.ItemMeta
import org.bukkit.persistence.PersistentDataContainer
import org.bukkit.persistence.PersistentDataType
import phonon.xv.component.*
import java.util.Stack

// Const indicating invalid dense array index
public const val INVALID_ELEMENT_ID: Int = -1

/**
 * Helper function to push an element into a dense array.
 * Validates that the index is at the end of the array.
 */
private fun <T> ArrayList<T>.pushAtDenseIndex(index: Int, value: T) {
    val storageSize = this.size
    if ( storageSize == index ) {
        this.add(value)
    } else {
        throw IllegalStateException("Archetype storage attempted to insert an element at a dense index larger than current size: ${index} (size = ${storageSize})")
    }
}

/**
 * Helper function to remove an element by swapping it with the last 
 * element in the array.
 */
private fun <T> ArrayList<T>.swapRemove(index: Int) {
    val storageSize = this.size
    if ( storageSize == 1 ) {
        this.removeAt(0)
    } else {
        // swap with last element
        val last = this[storageSize - 1]
        this[index] = last
        this.removeAt(storageSize - 1)
    }
}

/**
 * Note: keep in alphabetical order.
 */
public enum class VehicleComponentType {
    AMMO,
    FUEL,
    GUN_BARREL,
    GUN_TURRET,
    HEALTH,
    LAND_MOVEMENT_CONTROLS,
    SHIP_MOVEMENT_CONTROLS,
    MODEL,
    SEATS,
    SEATS_RAYCAST,
    SPAWN,
    TRANSFORM,
    ;

    public companion object {
        /**
         * Converts from compile-time generic vehicle component type. 
         */
        public inline fun <reified T: VehicleComponent<T>> from(): VehicleComponentType {
            return when ( T::class ) {
                AmmoComponent::class -> VehicleComponentType.AMMO
                FuelComponent::class -> VehicleComponentType.FUEL
                GunBarrelComponent::class -> VehicleComponentType.GUN_BARREL
                GunTurretComponent::class -> VehicleComponentType.GUN_TURRET
                HealthComponent::class -> VehicleComponentType.HEALTH
                LandMovementControlsComponent::class -> VehicleComponentType.LAND_MOVEMENT_CONTROLS
                ShipMovementControlsComponent::class -> VehicleComponentType.SHIP_MOVEMENT_CONTROLS
                ModelComponent::class -> VehicleComponentType.MODEL
                SeatsComponent::class -> VehicleComponentType.SEATS
                SeatsRaycastComponent::class -> VehicleComponentType.SEATS_RAYCAST
                SpawnComponent::class -> VehicleComponentType.SPAWN
                TransformComponent::class -> VehicleComponentType.TRANSFORM
                else -> throw Exception("Unknown component type")
            }
        }
    }
}

// namespaced keys, for use in toItem()
val AMMO_KEY = NamespacedKey("xv", "ammo")
val FUEL_KEY = NamespacedKey("xv", "fuel")
val GUN_BARREL_KEY = NamespacedKey("xv", "gun_barrel")
val GUN_TURRET_KEY = NamespacedKey("xv", "gun_turret")
val HEALTH_KEY = NamespacedKey("xv", "health")
val LAND_MOVEMENT_CONTROLS_KEY = NamespacedKey("xv", "land_movement_controls")
val SHIP_MOVEMENT_CONTROLS_KEY = NamespacedKey("xv", "ship_movement_controls")
val MODEL_KEY = NamespacedKey("xv", "model")
val SEATS_KEY = NamespacedKey("xv", "seats")
val SEATS_RAYCAST_KEY = NamespacedKey("xv", "seats_raycast")
val SPAWN_KEY = NamespacedKey("xv", "spawn")
val TRANSFORM_KEY = NamespacedKey("xv", "transform")

/**
 * VehicleComponents contains set of all possible components for a vehicle
 * element and a layout EnumSet that indicates the non-null components.
 */
public data class VehicleComponents(
    val layout: EnumSet<VehicleComponentType>,
    val ammo: AmmoComponent? = null,
    val fuel: FuelComponent? = null,
    val gunBarrel: GunBarrelComponent? = null,
    val gunTurret: GunTurretComponent? = null,
    val health: HealthComponent? = null,
    val landMovementControls: LandMovementControlsComponent? = null,
    val shipMovementControls: ShipMovementControlsComponent? = null,
    val model: ModelComponent? = null,
    val seats: SeatsComponent? = null,
    val seatsRaycast: SeatsRaycastComponent? = null,
    val spawn: SpawnComponent? = null,
    val transform: TransformComponent? = null,
) {
    /**
     * Deep-clones all components in this components set.
     */
    fun clone(): VehicleComponents {
        return VehicleComponents(
            layout,
            ammo = ammo?.copy(),
            fuel = fuel?.copy(),
            gunBarrel = gunBarrel?.copy(),
            gunTurret = gunTurret?.copy(),
            health = health?.copy(),
            landMovementControls = landMovementControls?.copy(),
            shipMovementControls = shipMovementControls?.copy(),
            model = model?.copy(),
            seats = seats?.copy(),
            seatsRaycast = seatsRaycast?.copy(),
            spawn = spawn?.copy(),
            transform = transform?.copy(),
        )
    }

    /**
     * During creation, inject player specific properties and generate
     * a new instance of components. Delegates injecting property
     * effects to each individual component.
     */
    fun injectSpawnProperties(
        location: Location?,
        player: Player?,
    ): VehicleComponents {
        return copy(
            ammo = ammo?.injectSpawnProperties(location, player),
            fuel = fuel?.injectSpawnProperties(location, player),
            gunBarrel = gunBarrel?.injectSpawnProperties(location, player),
            gunTurret = gunTurret?.injectSpawnProperties(location, player),
            health = health?.injectSpawnProperties(location, player),
            landMovementControls = landMovementControls?.injectSpawnProperties(location, player),
            shipMovementControls = shipMovementControls?.injectSpawnProperties(location, player),
            model = model?.injectSpawnProperties(location, player),
            seats = seats?.injectSpawnProperties(location, player),
            seatsRaycast = seatsRaycast?.injectSpawnProperties(location, player),
            spawn = spawn?.injectSpawnProperties(location, player),
            transform = transform?.injectSpawnProperties(location, player),
        )
    }

    /**
     * During creation, inject item specific properties and generate
     * a new instance of this component. Delegates injecting property
     * effects to each individual component.
     */
    fun injectItemProperties(
        itemData: PersistentDataContainer
    ): VehicleComponents {
        return copy(
            ammo = ammo?.injectItemProperties(itemData.get(AMMO_KEY, PersistentDataType.TAG_CONTAINER)),
            fuel = fuel?.injectItemProperties(itemData.get(FUEL_KEY, PersistentDataType.TAG_CONTAINER)),
            gunBarrel = gunBarrel?.injectItemProperties(itemData.get(GUN_BARREL_KEY, PersistentDataType.TAG_CONTAINER)),
            gunTurret = gunTurret?.injectItemProperties(itemData.get(GUN_TURRET_KEY, PersistentDataType.TAG_CONTAINER)),
            health = health?.injectItemProperties(itemData.get(HEALTH_KEY, PersistentDataType.TAG_CONTAINER)),
            landMovementControls = landMovementControls?.injectItemProperties(itemData.get(LAND_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER)),
            shipMovementControls = shipMovementControls?.injectItemProperties(itemData.get(SHIP_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER)),
            model = model?.injectItemProperties(itemData.get(MODEL_KEY, PersistentDataType.TAG_CONTAINER)),
            seats = seats?.injectItemProperties(itemData.get(SEATS_KEY, PersistentDataType.TAG_CONTAINER)),
            seatsRaycast = seatsRaycast?.injectItemProperties(itemData.get(SEATS_RAYCAST_KEY, PersistentDataType.TAG_CONTAINER)),
            spawn = spawn?.injectItemProperties(itemData.get(SPAWN_KEY, PersistentDataType.TAG_CONTAINER)),
            transform = transform?.injectItemProperties(itemData.get(TRANSFORM_KEY, PersistentDataType.TAG_CONTAINER)),
        )
    }

    /**
     * Serialize element component data into a Minecraft ItemStack item.
     * Delegates to each individual component, which can set properties
     * in item's meta, lore and persistent data container tree.
     * 
     * This mutates and modifies the input itemMeta, itemLore, and itemData
     * with new properties. So, user must be careful when elements overwrite
     * each other's properties.
     */
    fun toItemData(
        itemMeta: ItemMeta,
        itemLore: ArrayList<String>,
        itemData: PersistentDataContainer,
    ) {
        for ( c in layout ) { // only create data containers for components which exist in layout
            when ( c ) {
                VehicleComponentType.AMMO -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    ammo?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(AMMO_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.FUEL -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    fuel?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(FUEL_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.GUN_BARREL -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    gunBarrel?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(GUN_BARREL_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.GUN_TURRET -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    gunTurret?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(GUN_TURRET_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.HEALTH -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    health?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(HEALTH_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    landMovementControls?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(LAND_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    shipMovementControls?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SHIP_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.MODEL -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    model?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(MODEL_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SEATS -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    seats?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SEATS_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SEATS_RAYCAST -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    seatsRaycast?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SEATS_RAYCAST_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SPAWN -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    spawn?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SPAWN_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.TRANSFORM -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    transform?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(TRANSFORM_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                null -> {}
            }
        }
    }
    
    /**
     * During creation, inject json specific properties and generate
     * a new instance of this component. Used to load serialized vehicle
     * state from stored json objects. Delegates injecting property
     * effects to each individual component.
     *
     * The json object passed into this function should be the one
     * storing the data for the singular element, NOT the object
     * storing the entire vehicle. See the serde file for more details
     * on schema.
     */
    fun injectJsonProperties(
        json: JsonObject,
    ): VehicleComponents {
        return copy(
            ammo = ammo?.injectJsonProperties( json["ammo"]?.asJsonObject ),
            fuel = fuel?.injectJsonProperties( json["fuel"]?.asJsonObject ),
            gunBarrel = gunBarrel?.injectJsonProperties( json["gunBarrel"]?.asJsonObject ),
            gunTurret = gunTurret?.injectJsonProperties( json["gunTurret"]?.asJsonObject ),
            health = health?.injectJsonProperties( json["health"]?.asJsonObject ),
            landMovementControls = landMovementControls?.injectJsonProperties( json["landMovementControls"]?.asJsonObject ),
            shipMovementControls = shipMovementControls?.injectJsonProperties( json["shipMovementControls"]?.asJsonObject ),
            model = model?.injectJsonProperties( json["model"]?.asJsonObject ),
            seats = seats?.injectJsonProperties( json["seats"]?.asJsonObject ),
            seatsRaycast = seatsRaycast?.injectJsonProperties( json["seatsRaycast"]?.asJsonObject ),
            spawn = spawn?.injectJsonProperties( json["spawn"]?.asJsonObject ),
            transform = transform?.injectJsonProperties( json["transform"]?.asJsonObject ),
        )
    }
    
    /**
     * During creation, for each component, send post creation properties,
     * for post-processing after the vehicle has been created. Such as
     * setting up entity to vehicle mappings for armor stands.
     */
    fun afterVehicleCreated(
        vehicle: Vehicle,
        element: VehicleElement,
        entityVehicleData: HashMap<UUID, EntityVehicleData>,
    ) {
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.FUEL -> fuel?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.GUN_BARREL -> gunBarrel?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.GUN_TURRET -> gunTurret?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.HEALTH -> health?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> shipMovementControls?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.MODEL -> model?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SEATS -> seats?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SPAWN -> spawn?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.TRANSFORM -> transform?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                null -> {}
            }
        }
    }

    fun delete(
        vehicle: Vehicle,
        element: VehicleElement,
        entityVehicleData: HashMap<UUID, EntityVehicleData>
    ) {
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.FUEL -> fuel?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.GUN_BARREL -> gunBarrel?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.GUN_TURRET -> gunTurret?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.HEALTH -> health?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> shipMovementControls?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.MODEL -> model?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.SEATS -> seats?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.SPAWN -> spawn?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.TRANSFORM -> transform?.delete(vehicle, element, entityVehicleData)
                null -> {}
            }
        }
    }

    companion object {
        /**
         * Returns an empty vehicle components object.
         */
        public fun empty(): VehicleComponents {
            return VehicleComponents(
                layout = EnumSet.noneOf(VehicleComponentType::class.java),
            )
        }

        /**
         * Parses a vehicle components object from a toml table.
         */
        public fun fromToml(toml: TomlTable, logger: Logger? = null): VehicleComponents {
            // all possible components to be parsed
            var ammo: AmmoComponent? = null
            var fuel: FuelComponent? = null
            var gunBarrel: GunBarrelComponent? = null
            var gunTurret: GunTurretComponent? = null
            var health: HealthComponent? = null
            var landMovementControls: LandMovementControlsComponent? = null
            var shipMovementControls: ShipMovementControlsComponent? = null
            var model: ModelComponent? = null
            var seats: SeatsComponent? = null
            var seatsRaycast: SeatsRaycastComponent? = null
            var spawn: SpawnComponent? = null
            var transform: TransformComponent? = null

            // parse components from matching keys in toml
            val layout = EnumSet.noneOf(VehicleComponentType::class.java)
            val keys = toml.keySet()
            for ( k in keys ) {
                when ( k ) {
                    "name", "parent" -> continue
                    "ammo" -> {
                        layout.add(VehicleComponentType.AMMO)
                        ammo = AmmoComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "fuel" -> {
                        layout.add(VehicleComponentType.FUEL)
                        fuel = FuelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "gun_barrel" -> {
                        layout.add(VehicleComponentType.GUN_BARREL)
                        gunBarrel = GunBarrelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "gun_turret" -> {
                        layout.add(VehicleComponentType.GUN_TURRET)
                        gunTurret = GunTurretComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "health" -> {
                        layout.add(VehicleComponentType.HEALTH)
                        health = HealthComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "land_movement_controls" -> {
                        layout.add(VehicleComponentType.LAND_MOVEMENT_CONTROLS)
                        landMovementControls = LandMovementControlsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "ship_movement_controls" -> {
                        layout.add(VehicleComponentType.SHIP_MOVEMENT_CONTROLS)
                        shipMovementControls = ShipMovementControlsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "model" -> {
                        layout.add(VehicleComponentType.MODEL)
                        model = ModelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "seats" -> {
                        layout.add(VehicleComponentType.SEATS)
                        seats = SeatsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "seats_raycast" -> {
                        layout.add(VehicleComponentType.SEATS_RAYCAST)
                        seatsRaycast = SeatsRaycastComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "spawn" -> {
                        layout.add(VehicleComponentType.SPAWN)
                        spawn = SpawnComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "transform" -> {
                        layout.add(VehicleComponentType.TRANSFORM)
                        transform = TransformComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    else -> logger?.warning("Unknown key in vehicle element: $k")
                }
            }
            
            return VehicleComponents(
                layout,
                ammo,
                fuel,
                gunBarrel,
                gunTurret,
                health,
                landMovementControls,
                shipMovementControls,
                model,
                seats,
                seatsRaycast,
                spawn,
                transform,
            )
        }
    }
}

/**
 * Archetype, contains set of possible component storages which store
 * actual vehicle component instances. Components storages are sparse sets.
 * Archetype implements a packed struct-of-arrays format for fast iteration.
 * Element Id used to lookup an instance's packed array index.
 */
public class ArchetypeStorage(
    val layout: EnumSet<VehicleComponentType>,
    val maxElements: Int,
) {
    public var size: Int = 0
        internal set

    // sparse lookup from id => element
    // (note vehicle element id is just a typealias for int)
    // Internally lookup also stores a linked list of next free element,
    // so initialize with each element pointing to the next element
    // (e.g. next free element is the next element in the array)
    private val lookup: IntArray = IntArray(maxElements, { i -> i + 1 })

    // reverse lookup from dense array index => vehicle element id
    // only internal cuz iterator classes need it
    internal val elements: IntArray = IntArray(maxElements) { _ -> INVALID_ELEMENT_ID }

    // lookup implicit linked list head
    internal var nextFree: Int = 0

    // dense packed components storages
    // only components in layout will be non-null
    internal val ammo: ArrayList<AmmoComponent>? = if ( layout.contains(VehicleComponentType.AMMO) ) ArrayList() else null
    internal val fuel: ArrayList<FuelComponent>? = if ( layout.contains(VehicleComponentType.FUEL) ) ArrayList() else null
    internal val gunBarrel: ArrayList<GunBarrelComponent>? = if ( layout.contains(VehicleComponentType.GUN_BARREL) ) ArrayList() else null
    internal val gunTurret: ArrayList<GunTurretComponent>? = if ( layout.contains(VehicleComponentType.GUN_TURRET) ) ArrayList() else null
    internal val health: ArrayList<HealthComponent>? = if ( layout.contains(VehicleComponentType.HEALTH) ) ArrayList() else null
    internal val landMovementControls: ArrayList<LandMovementControlsComponent>? = if ( layout.contains(VehicleComponentType.LAND_MOVEMENT_CONTROLS) ) ArrayList() else null
    internal val shipMovementControls: ArrayList<ShipMovementControlsComponent>? = if ( layout.contains(VehicleComponentType.SHIP_MOVEMENT_CONTROLS) ) ArrayList() else null
    internal val model: ArrayList<ModelComponent>? = if ( layout.contains(VehicleComponentType.MODEL) ) ArrayList() else null
    internal val seats: ArrayList<SeatsComponent>? = if ( layout.contains(VehicleComponentType.SEATS) ) ArrayList() else null
    internal val seatsRaycast: ArrayList<SeatsRaycastComponent>? = if ( layout.contains(VehicleComponentType.SEATS_RAYCAST) ) ArrayList() else null
    internal val spawn: ArrayList<SpawnComponent>? = if ( layout.contains(VehicleComponentType.SPAWN) ) ArrayList() else null
    internal val transform: ArrayList<TransformComponent>? = if ( layout.contains(VehicleComponentType.TRANSFORM) ) ArrayList() else null

    // public getter "view"s: only expose immutable List interface
    public val ammoView: List<AmmoComponent>?
        get() = this.ammo
    public val fuelView: List<FuelComponent>?
        get() = this.fuel
    public val gunBarrelView: List<GunBarrelComponent>?
        get() = this.gunBarrel
    public val gunTurretView: List<GunTurretComponent>?
        get() = this.gunTurret
    public val healthView: List<HealthComponent>?
        get() = this.health
    public val landMovementControlsView: List<LandMovementControlsComponent>?
        get() = this.landMovementControls
    public val shipMovementControlsView: List<ShipMovementControlsComponent>?
        get() = this.shipMovementControls
    public val modelView: List<ModelComponent>?
        get() = this.model
    public val seatsView: List<SeatsComponent>?
        get() = this.seats
    public val seatsRaycastView: List<SeatsRaycastComponent>?
        get() = this.seatsRaycast
    public val spawnView: List<SpawnComponent>?
        get() = this.spawn
    public val transformView: List<TransformComponent>?
        get() = this.transform

    /**
     * Get component by id. Returns null if component is not in archetype.
     */
    inline fun <reified T: VehicleComponent<T>> getComponent(id: VehicleElementId): T? {
        val denseIndex = this.getDenseIndex(id)
        if ( denseIndex == INVALID_ELEMENT_ID ) {
            return null
        }
        
        return when ( T::class ) {
            AmmoComponent::class -> this.ammoView?.get(denseIndex) as T
            FuelComponent::class -> this.fuelView?.get(denseIndex) as T
            GunBarrelComponent::class -> this.gunBarrelView?.get(denseIndex) as T
            GunTurretComponent::class -> this.gunTurretView?.get(denseIndex) as T
            HealthComponent::class -> this.healthView?.get(denseIndex) as T
            LandMovementControlsComponent::class -> this.landMovementControlsView?.get(denseIndex) as T
            ShipMovementControlsComponent::class -> this.shipMovementControlsView?.get(denseIndex) as T
            ModelComponent::class -> this.modelView?.get(denseIndex) as T
            SeatsComponent::class -> this.seatsView?.get(denseIndex) as T
            SeatsRaycastComponent::class -> this.seatsRaycastView?.get(denseIndex) as T
            SpawnComponent::class -> this.spawnView?.get(denseIndex) as T
            TransformComponent::class -> this.transformView?.get(denseIndex) as T
            else -> throw Exception("Unknown component type.")
        }
    }

    /**
     * Get dense index from id.
     */
    public fun getDenseIndex(id: VehicleElementId): Int {
        return this.lookup[id]
    }

    /**
     * Insert components into the archetype. Returns a new element id
     * corresponding to its lookup index in the archetype.
     * Returns null if layout does not match or if the archetype is full.
     */
    public fun insert(
        components: VehicleComponents,
    ): VehicleElementId? {
        if ( this.layout != components.layout ) {
            return null
        }

        // try to allocate a new element id (lookup id)
        if ( size >= maxElements ) {
            return null
        }
        // new id is head of linked list
        val id = nextFree
        // set new head of implicit linked list
        nextFree = lookup[nextFree]
        // get dense index
        val denseIndex = size
        size += 1
        
        // set sparse <-> dense element mappings
        lookup[id] = denseIndex
        elements[denseIndex] = id

        // push components into storages
        for ( c in components.layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> {
                    this.ammo?.pushAtDenseIndex(denseIndex, components.ammo!!)
                }
                
                VehicleComponentType.FUEL -> {
                    this.fuel?.pushAtDenseIndex(denseIndex, components.fuel!!)
                }
                
                VehicleComponentType.GUN_BARREL -> {
                    this.gunBarrel?.pushAtDenseIndex(denseIndex, components.gunBarrel!!)
                }
                
                VehicleComponentType.GUN_TURRET -> {
                    this.gunTurret?.pushAtDenseIndex(denseIndex, components.gunTurret!!)
                }
                
                VehicleComponentType.HEALTH -> {
                    this.health?.pushAtDenseIndex(denseIndex, components.health!!)
                }
                
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> {
                    this.landMovementControls?.pushAtDenseIndex(denseIndex, components.landMovementControls!!)
                }
                
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> {
                    this.shipMovementControls?.pushAtDenseIndex(denseIndex, components.shipMovementControls!!)
                }
                
                VehicleComponentType.MODEL -> {
                    this.model?.pushAtDenseIndex(denseIndex, components.model!!)
                }
                
                VehicleComponentType.SEATS -> {
                    this.seats?.pushAtDenseIndex(denseIndex, components.seats!!)
                }
                
                VehicleComponentType.SEATS_RAYCAST -> {
                    this.seatsRaycast?.pushAtDenseIndex(denseIndex, components.seatsRaycast!!)
                }
                
                VehicleComponentType.SPAWN -> {
                    this.spawn?.pushAtDenseIndex(denseIndex, components.spawn!!)
                }
                
                VehicleComponentType.TRANSFORM -> {
                    this.transform?.pushAtDenseIndex(denseIndex, components.transform!!)
                }
                
                null -> {}
            }
        }

        return id
    }

    /**
     * Frees an element from the archetype. Removes all components
     * and frees element id.
     */
    public fun free(id: VehicleElementId, logger: Logger? = null) {
        // validate id is inside storage
        if ( id < 0 || id >= maxElements ) {
            logger?.severe("Archetype.remove() invalid element id: $id")
            return
        }

        // validate id inside dense array == id
        val denseIndex = lookup[id]
        if ( elements[denseIndex] != id ) {
            logger?.severe("Archetype.remove() element id not in array: $id")
            return
        }

        // swap values in dense array w/ last elt
        val swappedDenseIndex = size - 1
        val swappedId = elements[swappedDenseIndex]
        elements[denseIndex] = swappedId
        elements[swappedDenseIndex] = INVALID_ELEMENT_ID

        // update lookup and implicit list head
        lookup[id] = nextFree
        nextFree = id
        lookup[swappedId] = denseIndex

        // swap remove elements in component arrays
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.swapRemove(denseIndex)
                VehicleComponentType.FUEL -> fuel?.swapRemove(denseIndex)
                VehicleComponentType.GUN_BARREL -> gunBarrel?.swapRemove(denseIndex)
                VehicleComponentType.GUN_TURRET -> gunTurret?.swapRemove(denseIndex)
                VehicleComponentType.HEALTH -> health?.swapRemove(denseIndex)
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.swapRemove(denseIndex)
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> shipMovementControls?.swapRemove(denseIndex)
                VehicleComponentType.MODEL -> model?.swapRemove(denseIndex)
                VehicleComponentType.SEATS -> seats?.swapRemove(denseIndex)
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.swapRemove(denseIndex)
                VehicleComponentType.SPAWN -> spawn?.swapRemove(denseIndex)
                VehicleComponentType.TRANSFORM -> transform?.swapRemove(denseIndex)
                null -> {}
            }
        }
        
        // decrement archetype size
        size -= 1
    }
    
    /**
     * Remove all elements from archetype.
     */
    public fun clear() {
        size = 0

        // reset lookup implicit linked
        for ( i in 0 until maxElements ) {
            lookup[i] = i + 1
            elements[i] = INVALID_ELEMENT_ID
        }
        nextFree = 0
        ammo?.clear()
        fuel?.clear()
        gunBarrel?.clear()
        gunTurret?.clear()
        health?.clear()
        landMovementControls?.clear()
        shipMovementControls?.clear()
        model?.clear()
        seats?.clear()
        seatsRaycast?.clear()
        spawn?.clear()
        transform?.clear()
    }

    public companion object {
        /**
         * Higher order function that returns a function that gets a
         * Vehicle component type's storage within the archetype.
         * Needed to allows compile-time access to a type's component
         * storage in the archetype. Used for generic tuple iterators.
         * 
         * Internally does unsafe cast, since storages may be null.
         * Client caller must make sure archetypes have the storages.
         * 
         * Note: this may be generating a new lambda object at each call.
         * May want to cache the lambda object, or hard-code each function
         * in future.
         */
        @Suppress("UNCHECKED_CAST")
        public inline fun <reified T> accessor(): (ArchetypeStorage) -> List<T> {
            return when ( T::class ) {
                AmmoComponent::class -> { archetype -> archetype.ammoView as List<T> }
                FuelComponent::class -> { archetype -> archetype.fuelView as List<T> }
                GunBarrelComponent::class -> { archetype -> archetype.gunBarrelView as List<T> }
                GunTurretComponent::class -> { archetype -> archetype.gunTurretView as List<T> }
                HealthComponent::class -> { archetype -> archetype.healthView as List<T> }
                LandMovementControlsComponent::class -> { archetype -> archetype.landMovementControlsView as List<T> }
                ShipMovementControlsComponent::class -> { archetype -> archetype.shipMovementControlsView as List<T> }
                ModelComponent::class -> { archetype -> archetype.modelView as List<T> }
                SeatsComponent::class -> { archetype -> archetype.seatsView as List<T> }
                SeatsRaycastComponent::class -> { archetype -> archetype.seatsRaycastView as List<T> }
                SpawnComponent::class -> { archetype -> archetype.spawnView as List<T> }
                TransformComponent::class -> { archetype -> archetype.transformView as List<T> }
                else -> throw Exception("Unknown component type")
            }
        }
    }
}