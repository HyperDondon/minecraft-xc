/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Implements a "prototype" which is a cached base configuration
 * for a vehicle. This is used to create new vehicles. Rough process
 * involves using prototype as base then injecting specific data
 * for vehicle creation.
 * 
 *               Spawning                 Spawning from
 *              from item:                  save data
 * 
 *              prototype                   prototype 
 *                  |                           |     
 *                  |                           |     
 *     item         v              save         v     
 *     data ------> +              data ------> +     
 *                  |                           |     
 *                  |                           |     
 *    player        v                           |     
 *    event ------> +                           |     
 *     data         |                           |     
 *                  |                           |     
 *                  v                           v     
 *              components                  components
 */

package phonon.xv.core

import com.google.gson.JsonObject
import java.nio.file.Path
import java.util.EnumSet
import java.util.UUID
import java.util.logging.Logger
import java.util.LinkedList
import java.util.ArrayDeque
import java.util.Collections
import kotlin.math.max
import org.tomlj.Toml
import org.tomlj.TomlTable
import org.bukkit.Location
import org.bukkit.Material
import org.bukkit.NamespacedKey
import org.bukkit.entity.Player
import org.bukkit.inventory.ItemStack
import org.bukkit.inventory.meta.ItemMeta
import org.bukkit.persistence.PersistentDataAdapterContext
import org.bukkit.persistence.PersistentDataContainer
import org.bukkit.persistence.PersistentDataType
import phonon.xv.XV
import phonon.xv.ITEM_KEY_PROTOTYPE
import phonon.xv.ITEM_KEY_ELEMENTS
import phonon.xv.component.*

// namespaced keys, for use in toItem()
val AMMO_KEY = NamespacedKey("xv", "ammo")
val FUEL_KEY = NamespacedKey("xv", "fuel")
val GUN_BARREL_KEY = NamespacedKey("xv", "gun_barrel")
val GUN_TURRET_KEY = NamespacedKey("xv", "gun_turret")
val HEALTH_KEY = NamespacedKey("xv", "health")
val LAND_MOVEMENT_CONTROLS_KEY = NamespacedKey("xv", "land_movement_controls")
val SHIP_MOVEMENT_CONTROLS_KEY = NamespacedKey("xv", "ship_movement_controls")
val MODEL_KEY = NamespacedKey("xv", "model")
val SEATS_KEY = NamespacedKey("xv", "seats")
val SEATS_RAYCAST_KEY = NamespacedKey("xv", "seats_raycast")
val SPAWN_KEY = NamespacedKey("xv", "spawn")
val TRANSFORM_KEY = NamespacedKey("xv", "transform")

/**
 * VehiclePrototype defines elements in a vehicle. Used as a base
 * object to create new vehicles. The elements form a tree and must
 * always be depth sorted.
 */
public data class VehiclePrototype(
    val name: String,
    // item name
    val itemName: String,
    // item base lore description
    val itemLore: List<String>,
    // tree depth-sorted elements
    val elements: List<VehicleElementPrototype>,
    // index of parent element in elements list
    val parentIndex: IntArray,
    // depth of each element in the tree
    val elementsDepth: IntArray,
    // vehicle element tree max depth
    val maxDepth: Int,
) {
    val uuid: UUID = UUID.randomUUID()

    // root elements have no parent
    val rootElements: List<VehicleElementPrototype> = elements.filter { e -> e.parent == null }.toList()

    // pre-computed children indices for each element
    // (referenced by the element index in elements list)
    val childrenIndices: Array<IntArray>

    init {
        val children = Array<ArrayList<Int>>(elements.size, { ArrayList() })
        for ( (idx, p) in parentIndex.withIndex() ) {
            if ( p != -1 ) {
                children[p].add(idx)
            }
        }
        childrenIndices = Array(children.size, { children[it].toIntArray() })
    }

    /**
     * Convert this prototype to an item stack with given material.
     */
    public fun toItemStack(material: Material): ItemStack {
        val item = ItemStack(material, 1)
        val itemMeta = item.getItemMeta()
        val itemData = itemMeta.getPersistentDataContainer()

        // attach prototype name
        itemData.set(ITEM_KEY_PROTOTYPE, PersistentDataType.STRING, this.name)

        // item name
        itemMeta.setDisplayName(this.itemName)

        // item lore (initialized with base prototype lore)
        val itemLore = ArrayList<String>(this.itemLore)
        
        // attach element data
        val elementsData = itemData.adapterContext.newPersistentDataContainer()
        for ( elem in this.elements ) {
            val elemData = elementsData.adapterContext.newPersistentDataContainer()
            elem.toItemData(itemMeta, itemLore, elemData)
            elementsData.set(elem.itemKey(), PersistentDataType.TAG_CONTAINER, elemData)
        }
        itemData.set(ITEM_KEY_ELEMENTS, PersistentDataType.TAG_CONTAINER, elementsData)

        itemMeta.setLore(itemLore)
        item.setItemMeta(itemMeta)
        return item
    }

    companion object {
        /**
         * Tries to create a vehicle prototype from a list of unsorted
         * element prototypes. This returns null if any cycle is detected
         * between elements. This uses Kahn's algorithm to sort the elements
         * topologically, so that we can sort and detect cycles at same time
         * (even though topological sort normally unneeded since only 1 parent
         * per node).
         */
        public fun fromUnsortedElements(
            name: String,
            itemName: String,
            itemLore: List<String>,
            unsortedElements: List<VehicleElementPrototype>,
            logger: Logger? = null,
        ): VehiclePrototype? {
            
            // build map from name -> unsorted index
            // also validates and makes sure no duplicate names
            val nameToIndex = HashMap<String, Int>()
            for ( (idx, e) in unsortedElements.withIndex() ) {
                if ( nameToIndex.put(e.name, idx) !== null ) { // fails if name already in set
                    logger?.warning("VehiclePrototype.fromUnsortedElements: duplicate element name ${e.name} while creating prototype ${name}")
                    return null
                }
            }

            // build parent-children adjacency list as arrays, each index
            // 'n' corresponds to the element at unsortedElements[n]'s parent
            // and children:
            //
            // parents =  [ - ]   [ 0 ] [ 0 ] ...
            // children = [[1,2]] [[] ] [[] ] ...
            //
            //              ^             ^
            //              |             |
            //            node0          node2
            //        parent = -1        parent = 0
            //        children = [1,2]   children = []
            val children = Array<ArrayList<Int>>(unsortedElements.size, { ArrayList() })
            val unsortedParents = IntArray(unsortedElements.size, { -1 })
            for ( (idx, e) in unsortedElements.withIndex() ) {
                val parentName = e.parent
                if ( parentName != null ) {
                    val parentIdx = nameToIndex[parentName]
                    if ( parentIdx == null ) {
                        logger?.warning("VehiclePrototype.fromUnsortedElements: element ${e.name} has parent ${parentName} which does not exist in prototype ${name}")
                        return null
                    }
                    unsortedParents[idx] = parentIdx
                    children[parentIdx].add(idx)
                }
            }

            // first topologically sort using kahn's algorithm
            // (in retrospect, unnecessary since we only allow 1 parent,
            // but at least this is non-recursive)

            // queue of nodes with no incoming edges (e.g. no children)
            val queue = ArrayDeque<Int>()
            for ( (idx, c) in children.withIndex() ) {
                if ( c.isEmpty() ) {
                    queue.add(idx)
                }
            }

            // make sure queue size > 0, otherwise no root elements
            if ( queue.isEmpty() ) {
                logger?.warning("VehiclePrototype.fromUnsortedElements: no root elements in prototype ${name}")
                return null
            }
            
            // sorted elements and sorted parents
            val sorted = ArrayList<VehicleElementPrototype>(unsortedElements.size)
            val parents = ArrayList<Int>(unsortedElements.size)

            while ( !queue.isEmpty() ) {
                val n = queue.removeFirst()
                sorted.add(unsortedElements[n])
                parents.add(unsortedParents[n])

                // remove node n from tree
                val parentIdx = unsortedParents[n]
                if ( parentIdx != -1 ) {
                    children[parentIdx].remove(n) // removes n, not the index n

                    // if parent has no more children, add to queue
                    if ( children[parentIdx].isEmpty() ) {
                        queue.add(parentIdx)
                    }
                }
            }
            
            // if we didn't add all elements to sorted, then there was a cycle
            if ( sorted.size != unsortedElements.size ) {
                logger?.warning("VehiclePrototype.fromUnsortedElements: cycle detected in prototype ${name} (sorted.size ${sorted.size} != unsortedElements.size ${unsortedElements.size}})")
                return null
            }
            
            // reverse sorted list so that it iterates from parents to children
            Collections.reverse(sorted)
            Collections.reverse(parents)

            // re-order topologically sorted list to be tree depth-sorted
            // just iterate and increment depth of parent
            val depth = IntArray(unsortedElements.size, { 0 })
            var maxDepth = 0
            for ( (idx, p) in parents.withIndex() ) {
                if ( p != -1 ) {
                    depth[idx] = depth[p] + 1
                    maxDepth = max(maxDepth, depth[idx])
                }
            }
            
            // scatter the topologically sorted elements into depth-sorted bin indices
            // 1. create bin sizes and current bin indices 
            // 2. scatter elements into bin at offset, then increment offset
            val depthSortedIndices = IntArray(unsortedElements.size, { -1 })
            val depthSortedParents = IntArray(unsortedElements.size, { -1 })
            val depthSortedDepths = IntArray(unsortedElements.size, { -1 })
            val depthBinSizes = IntArray(maxDepth + 1, { 0 })
            val depthBinOffsets = IntArray(maxDepth + 1, { 0 })
            for ( d in depth ) {
                depthBinSizes[d] += 1
            }
            for ( d in 1..maxDepth ) {
                depthBinOffsets[d] = depthBinOffsets[d-1] + depthBinSizes[d-1]
            }
            for ( (idx, d) in depth.withIndex() ) {
                val i = depthBinOffsets[d] // output scatter index
                depthSortedIndices[i] = idx
                depthSortedParents[i] = parents[idx]
                depthSortedDepths[i] = d

                depthBinOffsets[d] += 1
            }

            // use depth sorted indices to scatter sort elements
            val depthSortedElements = depthSortedIndices.map { unsortedElements[it] }
            
            return VehiclePrototype(
                name,
                itemName,
                itemLore,
                depthSortedElements,
                depthSortedParents,
                depthSortedDepths,
                maxDepth,
            )
        }
        
        /**
         * Try to load a vehicle prototype from a toml file.
         * If any of the internal elements fails to parse, this will
         * print an error and return a null.
         */
        public fun fromTomlFile(source: Path, logger: Logger? = null): VehiclePrototype? {
            try {
                val toml = Toml.parse(source)

                // vehicle prototype name
                val name = toml.getString("name") ?: ""

                // item properties
                val itemName = toml.getString("item_name") ?: name
                val itemLore = toml.getArrayOrEmpty("item_lore").toList().map { it.toString() }

                // vehicle elements
                val unsortedElements = ArrayList<VehicleElementPrototype>()

                // if this contains an elements table, parse each element
                // else, parse entire doc as single toml table
                toml.getArray("elements")?.let { elems ->
                    for ( i in 0 until elems.size() ) {
                        unsortedElements.add(VehicleElementPrototype.fromToml(elems.getTable(i), vehicleName = name))
                    }
                } ?: unsortedElements.add(VehicleElementPrototype.fromToml(toml, vehicleName = name))

                return VehiclePrototype.fromUnsortedElements(
                    name,
                    itemName,
                    itemLore,
                    unsortedElements,
                )
            } catch (e: Exception) {
                logger?.warning("Failed to parse landmine file: ${source.toString()}, ${e}")
                e.printStackTrace()
                return null
            }
        }
    }
}

/**
 * VehicleElementPrototype defines a vehicle element's initial components.
 * Contains all possible components, but only the ones in layout should
 * be non-null.
 */
public data class VehicleElementPrototype(
    val name: String,
    val parent: String?,
    val vehicleName: String,
    val layout: EnumSet<VehicleComponentType>,
    val uuid: UUID = UUID.randomUUID(), // uuid as input, when loading vehicles this is overwritten by saved uuid
    val ammo: AmmoComponent? = null,
    val fuel: FuelComponent? = null,
    val gunBarrel: GunBarrelComponent? = null,
    val gunTurret: GunTurretComponent? = null,
    val health: HealthComponent? = null,
    val landMovementControls: LandMovementControlsComponent? = null,
    val shipMovementControls: ShipMovementControlsComponent? = null,
    val model: ModelComponent? = null,
    val seats: SeatsComponent? = null,
    val seatsRaycast: SeatsRaycastComponent? = null,
    val spawn: SpawnComponent? = null,
    val transform: TransformComponent? = null,
) {
    /**
     * Return an item namespace key.
     */
    fun itemKey(): NamespacedKey {
        return NamespacedKey("xv", this.name)
    }

    /**
     * During creation, inject player specific properties and generate
     * a new instance of this prototype. Delegates injecting property
     * effects to each individual component.
     */
    fun injectSpawnProperties(
        location: Location?,
        player: Player?,
    ): VehicleElementPrototype {
        return copy(
            ammo = ammo?.injectSpawnProperties(location, player),
            fuel = fuel?.injectSpawnProperties(location, player),
            gunBarrel = gunBarrel?.injectSpawnProperties(location, player),
            gunTurret = gunTurret?.injectSpawnProperties(location, player),
            health = health?.injectSpawnProperties(location, player),
            landMovementControls = landMovementControls?.injectSpawnProperties(location, player),
            shipMovementControls = shipMovementControls?.injectSpawnProperties(location, player),
            model = model?.injectSpawnProperties(location, player),
            seats = seats?.injectSpawnProperties(location, player),
            seatsRaycast = seatsRaycast?.injectSpawnProperties(location, player),
            spawn = spawn?.injectSpawnProperties(location, player),
            transform = transform?.injectSpawnProperties(location, player),
        )
    }

    /**
     * During creation, inject item specific properties and generate
     * a new instance of this component. Delegates injecting property
     * effects to each individual component.
     */
    fun injectItemProperties(
        itemData: PersistentDataContainer
    ): VehicleElementPrototype {
        return copy(
            ammo = ammo?.injectItemProperties(itemData.get(AMMO_KEY, PersistentDataType.TAG_CONTAINER)),
            fuel = fuel?.injectItemProperties(itemData.get(FUEL_KEY, PersistentDataType.TAG_CONTAINER)),
            gunBarrel = gunBarrel?.injectItemProperties(itemData.get(GUN_BARREL_KEY, PersistentDataType.TAG_CONTAINER)),
            gunTurret = gunTurret?.injectItemProperties(itemData.get(GUN_TURRET_KEY, PersistentDataType.TAG_CONTAINER)),
            health = health?.injectItemProperties(itemData.get(HEALTH_KEY, PersistentDataType.TAG_CONTAINER)),
            landMovementControls = landMovementControls?.injectItemProperties(itemData.get(LAND_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER)),
            shipMovementControls = shipMovementControls?.injectItemProperties(itemData.get(SHIP_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER)),
            model = model?.injectItemProperties(itemData.get(MODEL_KEY, PersistentDataType.TAG_CONTAINER)),
            seats = seats?.injectItemProperties(itemData.get(SEATS_KEY, PersistentDataType.TAG_CONTAINER)),
            seatsRaycast = seatsRaycast?.injectItemProperties(itemData.get(SEATS_RAYCAST_KEY, PersistentDataType.TAG_CONTAINER)),
            spawn = spawn?.injectItemProperties(itemData.get(SPAWN_KEY, PersistentDataType.TAG_CONTAINER)),
            transform = transform?.injectItemProperties(itemData.get(TRANSFORM_KEY, PersistentDataType.TAG_CONTAINER)),
        )
    }

    /**
     * Serialize element component data into a Minecraft ItemStack item.
     * Delegates to each individual component, which can set properties
     * in item's meta, lore and persistent data container tree.
     * 
     * This mutates and modifies the input itemMeta, itemLore, and itemData
     * with new properties. So, user must be careful when elements overwrite
     * each other's properties.
     */
    fun toItemData(
        itemMeta: ItemMeta,
        itemLore: ArrayList<String>,
        itemData: PersistentDataContainer,
    ) {
        for ( c in layout ) { // only create data containers for components which exist in layout
            when ( c ) {
                VehicleComponentType.AMMO -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    ammo?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(AMMO_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.FUEL -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    fuel?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(FUEL_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.GUN_BARREL -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    gunBarrel?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(GUN_BARREL_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.GUN_TURRET -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    gunTurret?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(GUN_TURRET_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.HEALTH -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    health?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(HEALTH_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    landMovementControls?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(LAND_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    shipMovementControls?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SHIP_MOVEMENT_CONTROLS_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.MODEL -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    model?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(MODEL_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SEATS -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    seats?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SEATS_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SEATS_RAYCAST -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    seatsRaycast?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SEATS_RAYCAST_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.SPAWN -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    spawn?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(SPAWN_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                VehicleComponentType.TRANSFORM -> {
                    val componentDataContainer = itemData.adapterContext.newPersistentDataContainer()
                    transform?.toItemData(itemMeta, itemLore, componentDataContainer)
                    itemData.set(TRANSFORM_KEY, PersistentDataType.TAG_CONTAINER, componentDataContainer)
                }
                null -> {}
            }
        }
    }
    
    /**
     * During creation, inject json specific properties and generate
     * a new instance of this component. Used to load serialized vehicle
     * state from stored json objects. Delegates injecting property
     * effects to each individual component.
     *
     * The json object passed into this function should be the one
     * storing the data for the singular element, NOT the object
     * storing the entire vehicle. See the serde file for more details
     * on schema.
     */
    fun injectJsonProperties(
        json: JsonObject,
    ): VehicleElementPrototype {
        val componentsJson = json["components"]!!.asJsonObject
        return copy(
            uuid = UUID.fromString( json["uuid"].asString ),
            ammo = ammo?.injectJsonProperties( componentsJson["ammo"]?.asJsonObject ),
            fuel = fuel?.injectJsonProperties( componentsJson["fuel"]?.asJsonObject ),
            gunBarrel = gunBarrel?.injectJsonProperties( componentsJson["gunBarrel"]?.asJsonObject ),
            gunTurret = gunTurret?.injectJsonProperties( componentsJson["gunTurret"]?.asJsonObject ),
            health = health?.injectJsonProperties( componentsJson["health"]?.asJsonObject ),
            landMovementControls = landMovementControls?.injectJsonProperties( componentsJson["landMovementControls"]?.asJsonObject ),
            shipMovementControls = shipMovementControls?.injectJsonProperties( componentsJson["shipMovementControls"]?.asJsonObject ),
            model = model?.injectJsonProperties( componentsJson["model"]?.asJsonObject ),
            seats = seats?.injectJsonProperties( componentsJson["seats"]?.asJsonObject ),
            seatsRaycast = seatsRaycast?.injectJsonProperties( componentsJson["seatsRaycast"]?.asJsonObject ),
            spawn = spawn?.injectJsonProperties( componentsJson["spawn"]?.asJsonObject ),
            transform = transform?.injectJsonProperties( componentsJson["transform"]?.asJsonObject ),
        )
    }
    
    /**
     * During creation, for each component, send post creation properties,
     * for post-processing after the vehicle has been created. Such as
     * setting up entity to vehicle mappings for armor stands.
     */
    fun afterVehicleCreated(
        vehicle: Vehicle,
        element: VehicleElement,
        entityVehicleData: HashMap<UUID, EntityVehicleData>,
    ) {
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.FUEL -> fuel?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.GUN_BARREL -> gunBarrel?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.GUN_TURRET -> gunTurret?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.HEALTH -> health?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> shipMovementControls?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.MODEL -> model?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SEATS -> seats?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SPAWN -> spawn?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.TRANSFORM -> transform?.afterVehicleCreated(
                    vehicle=vehicle,
                    element=element,
                    entityVehicleData=entityVehicleData,
                )
                null -> {}
            }
        }
    }

    fun delete(
        vehicle: Vehicle,
        element: VehicleElement,
        entityVehicleData: HashMap<UUID, EntityVehicleData>
    ) {
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.FUEL -> fuel?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.GUN_BARREL -> gunBarrel?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.GUN_TURRET -> gunTurret?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.HEALTH -> health?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.SHIP_MOVEMENT_CONTROLS -> shipMovementControls?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.MODEL -> model?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.SEATS -> seats?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.SPAWN -> spawn?.delete(vehicle, element, entityVehicleData)
                VehicleComponentType.TRANSFORM -> transform?.delete(vehicle, element, entityVehicleData)
                null -> {}
            }
        }
    }

    companion object {
        public fun fromToml(toml: TomlTable, logger: Logger? = null, vehicleName: String): VehicleElementPrototype {
            // element built-in properties
            val name = toml.getString("name") ?: ""
            val parent = toml.getString("parent")
            
            // all possible components to be parsed
            var ammo: AmmoComponent? = null
            var fuel: FuelComponent? = null
            var gunBarrel: GunBarrelComponent? = null
            var gunTurret: GunTurretComponent? = null
            var health: HealthComponent? = null
            var landMovementControls: LandMovementControlsComponent? = null
            var shipMovementControls: ShipMovementControlsComponent? = null
            var model: ModelComponent? = null
            var seats: SeatsComponent? = null
            var seatsRaycast: SeatsRaycastComponent? = null
            var spawn: SpawnComponent? = null
            var transform: TransformComponent? = null

            // parse components from matching keys in toml
            val layout = EnumSet.noneOf(VehicleComponentType::class.java)
            val keys = toml.keySet()
            for ( k in keys ) {
                when ( k ) {
                    "name", "parent" -> continue
                    "ammo" -> {
                        layout.add(VehicleComponentType.AMMO)
                        ammo = AmmoComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "fuel" -> {
                        layout.add(VehicleComponentType.FUEL)
                        fuel = FuelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "gun_barrel" -> {
                        layout.add(VehicleComponentType.GUN_BARREL)
                        gunBarrel = GunBarrelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "gun_turret" -> {
                        layout.add(VehicleComponentType.GUN_TURRET)
                        gunTurret = GunTurretComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "health" -> {
                        layout.add(VehicleComponentType.HEALTH)
                        health = HealthComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "land_movement_controls" -> {
                        layout.add(VehicleComponentType.LAND_MOVEMENT_CONTROLS)
                        landMovementControls = LandMovementControlsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "ship_movement_controls" -> {
                        layout.add(VehicleComponentType.SHIP_MOVEMENT_CONTROLS)
                        shipMovementControls = ShipMovementControlsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "model" -> {
                        layout.add(VehicleComponentType.MODEL)
                        model = ModelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "seats" -> {
                        layout.add(VehicleComponentType.SEATS)
                        seats = SeatsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "seats_raycast" -> {
                        layout.add(VehicleComponentType.SEATS_RAYCAST)
                        seatsRaycast = SeatsRaycastComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "spawn" -> {
                        layout.add(VehicleComponentType.SPAWN)
                        spawn = SpawnComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "transform" -> {
                        layout.add(VehicleComponentType.TRANSFORM)
                        transform = TransformComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    else -> logger?.warning("Unknown key in vehicle element: $k")
                }
            }
            
            return VehicleElementPrototype(
                name,
                parent,
                vehicleName,
                layout,
                UUID.randomUUID(),
                ammo,
                fuel,
                gunBarrel,
                gunTurret,
                health,
                landMovementControls,
                shipMovementControls,
                model,
                seats,
                seatsRaycast,
                spawn,
                transform,
            )
        }
    }
}