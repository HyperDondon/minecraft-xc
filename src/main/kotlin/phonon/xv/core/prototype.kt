/**
 * FILE IS GENERATED BY CODEGEN SCRIPT, WHICH IMPLEMENTS ALL 
 * COMPONENT TYPES. DO NOT EDIT THIS FILE DIRECTLY.
 * 
 * Implements a "prototype" which is a cached base configuration
 * for a vehicle. This is used to create new vehicles. Rough process
 * involves using prototype as base then injecting specific data
 * for vehicle creation.
 * 
 *               Spawning                 Spawning from
 *              from item:                  save data
 * 
 *              prototype                   prototype 
 *                  |                           |     
 *                  |                           |     
 *     item         v              save         v     
 *     data ------> +              data ------> +     
 *                  |                           |     
 *                  |                           |     
 *    player        v                           |     
 *    event ------> +                           |     
 *     data         |                           |     
 *                  |                           |     
 *                  v                           v     
 *              components                  components
 */

package phonon.xv.core

import com.google.gson.JsonObject
import java.nio.file.Path
import java.util.EnumSet
import java.util.UUID
import java.util.logging.Logger
import java.util.LinkedList
import java.util.ArrayDeque
import java.util.Collections
import kotlin.math.max
import org.tomlj.Toml
import org.tomlj.TomlTable
import org.bukkit.Location
import org.bukkit.entity.Player
import org.bukkit.inventory.ItemStack
import org.bukkit.inventory.meta.ItemMeta
import org.bukkit.persistence.PersistentDataContainer
import phonon.xv.XV
import phonon.xv.component.*


/**
 * VehiclePrototype defines elements in a vehicle. Used as a base
 * object to create new vehicles. The elements form a tree and must
 * always be depth sorted.
 */
public data class VehiclePrototype(
    val name: String,
    // tree depth-sorted elements
    val elements: List<VehicleElementPrototype>,
    // index of parent element in elements list
    val parentIndex: IntArray,
    // depth of each element in the tree
    val elementsDepth: IntArray,
    // vehicle element tree max depth
    val maxDepth: Int,
) {
    // root elements have no parent
    val rootElements: List<VehicleElementPrototype> = elements.filter { e -> e.parent == null }.toList()

    // pre-computed children indices for each element
    // (referenced by the element index in elements list)
    val childrenIndices: Array<IntArray>

    init {
        val children = Array<ArrayList<Int>>(elements.size, { ArrayList() })
        for ( (idx, p) in parentIndex.withIndex() ) {
            if ( p != -1 ) {
                children[p].add(idx)
            }
        }
        childrenIndices = Array(children.size, { children[it].toIntArray() })
    }

    val uuid: UUID = UUID.randomUUID()

    companion object {
        /**
         * Tries to create a vehicle prototype from a list of unsorted
         * element prototypes. This returns null if any cycle is detected
         * between elements. This uses Kahn's algorithm to sort the elements
         * topologically, so that we can sort and detect cycles at same time
         * (even though topological sort normally unneeded since only 1 parent
         * per node).
         */
        public fun fromUnsortedElements(
            name: String,
            unsortedElements: List<VehicleElementPrototype>,
            logger: Logger? = null,
        ): VehiclePrototype? {
            
            // build map from name -> unsorted index
            // also validates and makes sure no duplicate names
            val nameToIndex = HashMap<String, Int>()
            for ( (idx, e) in unsortedElements.withIndex() ) {
                if ( nameToIndex.put(e.name, idx) !== null ) { // fails if name already in set
                    logger?.warning("VehiclePrototype.fromUnsortedElements: duplicate element name ${e.name} while creating prototype ${name}")
                    return null
                }
            }

            // build parent-children adjacency list as arrays, each index
            // 'n' corresponds to the element at unsortedElements[n]'s parent
            // and children:
            //
            // parents =  [ - ]   [ 0 ] [ 0 ] ...
            // children = [[1,2]] [[] ] [[] ] ...
            //
            //              ^             ^
            //              |             |
            //            node0          node2
            //        parent = -1        parent = 0
            //        children = [1,2]   children = []
            val children = Array<ArrayList<Int>>(unsortedElements.size, { ArrayList() })
            val unsortedParents = IntArray(unsortedElements.size, { -1 })
            for ( (idx, e) in unsortedElements.withIndex() ) {
                val parentName = e.parent
                if ( parentName != null ) {
                    val parentIdx = nameToIndex[parentName]
                    if ( parentIdx == null ) {
                        logger?.warning("VehiclePrototype.fromUnsortedElements: element ${e.name} has parent ${parentName} which does not exist in prototype ${name}")
                        return null
                    }
                    unsortedParents[idx] = parentIdx
                    children[parentIdx].add(idx)
                }
            }

            // first topologically sort using kahn's algorithm
            // (in retrospect, unnecessary since we only allow 1 parent,
            // but at least this is non-recursive)

            // queue of nodes with no incoming edges (e.g. no children)
            val queue = ArrayDeque<Int>()
            for ( (idx, c) in children.withIndex() ) {
                if ( c.isEmpty() ) {
                    queue.add(idx)
                }
            }

            // make sure queue size > 0, otherwise no root elements
            if ( queue.isEmpty() ) {
                logger?.warning("VehiclePrototype.fromUnsortedElements: no root elements in prototype ${name}")
                return null
            }
            
            // sorted elements and sorted parents
            val sorted = ArrayList<VehicleElementPrototype>(unsortedElements.size)
            val parents = ArrayList<Int>(unsortedElements.size)

            while ( !queue.isEmpty() ) {
                val n = queue.removeFirst()
                sorted.add(unsortedElements[n])
                parents.add(unsortedParents[n])

                // remove node n from tree
                val parentIdx = unsortedParents[n]
                if ( parentIdx != -1 ) {
                    children[parentIdx].remove(n) // removes n, not the index n

                    // if parent has no more children, add to queue
                    if ( children[parentIdx].isEmpty() ) {
                        queue.add(parentIdx)
                    }
                }
            }
            
            // if we didn't add all elements to sorted, then there was a cycle
            if ( sorted.size != unsortedElements.size ) {
                logger?.warning("VehiclePrototype.fromUnsortedElements: cycle detected in prototype ${name} (sorted.size ${sorted.size} != unsortedElements.size ${unsortedElements.size}})")
                return null
            }
            
            // reverse sorted list so that it iterates from parents to children
            Collections.reverse(sorted)
            Collections.reverse(parents)

            // re-order topologically sorted list to be tree depth-sorted
            // just iterate and increment depth of parent
            val depth = IntArray(unsortedElements.size, { 0 })
            var maxDepth = 0
            for ( (idx, p) in parents.withIndex() ) {
                if ( p != -1 ) {
                    depth[idx] = depth[p] + 1
                    maxDepth = max(maxDepth, depth[idx])
                }
            }
            
            // scatter the topologically sorted elements into depth-sorted bin indices
            // 1. create bin sizes and current bin indices 
            // 2. scatter elements into bin at offset, then increment offset
            val depthSortedIndices = IntArray(unsortedElements.size, { -1 })
            val depthSortedParents = IntArray(unsortedElements.size, { -1 })
            val depthSortedDepths = IntArray(unsortedElements.size, { -1 })
            val depthBinSizes = IntArray(maxDepth + 1, { 0 })
            val depthBinOffsets = IntArray(maxDepth + 1, { 0 })
            for ( d in depth ) {
                depthBinSizes[d] += 1
            }
            for ( d in 1..maxDepth ) {
                depthBinOffsets[d] = depthBinOffsets[d-1] + depthBinSizes[d-1]
            }
            for ( (idx, d) in depth.withIndex() ) {
                val i = depthBinOffsets[d] // output scatter index
                depthSortedIndices[i] = idx
                depthSortedParents[i] = parents[idx]
                depthSortedDepths[i] = d

                depthBinOffsets[d] += 1
            }

            // use depth sorted indices to scatter sort elements
            val depthSortedElements = depthSortedIndices.map { unsortedElements[it] }
            
            return VehiclePrototype(
                name,
                depthSortedElements,
                depthSortedParents,
                depthSortedDepths,
                maxDepth,
            )
        }
        
        /**
         * Try to load a vehicle prototype from a toml file.
         * If any of the internal elements fails to parse, this will
         * print an error and return a null.
         */
        public fun fromTomlFile(source: Path, logger: Logger? = null): VehiclePrototype? {
            try {
                val toml = Toml.parse(source)

                // main vehicle name
                val name = toml.getString("name") ?: ""
                val unsortedElements = ArrayList<VehicleElementPrototype>()

                // if this contains an elements table, parse each element
                // else, parse entire doc as single toml table
                toml.getArray("elements")?.let { elems ->
                    for ( i in 0 until elems.size() ) {
                        unsortedElements.add(VehicleElementPrototype.fromToml(elems.getTable(i), vehicleName = name))
                    }
                } ?: unsortedElements.add(VehicleElementPrototype.fromToml(toml, vehicleName = name))

                return VehiclePrototype.fromUnsortedElements(name, unsortedElements)
            } catch (e: Exception) {
                logger?.warning("Failed to parse landmine file: ${source.toString()}, ${e}")
                e.printStackTrace()
                return null
            }
        }
    }
}

/**
 * VehicleElementPrototype defines a vehicle element's initial components.
 * Contains all possible components, but only the ones in layout should
 * be non-null.
 */
public data class VehicleElementPrototype(
    val name: String,
    val parent: String?,
    val vehicleName: String,
    val layout: EnumSet<VehicleComponentType>,
    val ammo: AmmoComponent? = null,
    val fuel: FuelComponent? = null,
    val gunBarrel: GunBarrelComponent? = null,
    val gunTurret: GunTurretComponent? = null,
    val health: HealthComponent? = null,
    val landMovementControls: LandMovementControlsComponent? = null,
    val model: ModelComponent? = null,
    val seats: SeatsComponent? = null,
    val seatsRaycast: SeatsRaycastComponent? = null,
    val spawn: SpawnComponent? = null,
    val transform: TransformComponent? = null,
    val uuid: UUID = UUID.randomUUID()
) {
    // uuid to be passed into constructor of
    // vehicle element


    /**
     * During creation, inject player specific properties and generate
     * a new instance of this prototype. Delegates injecting property
     * effects to each individual component.
     */
    fun injectSpawnProperties(
        location: Location?,
        player: Player?,
    ): VehicleElementPrototype {
        return copy(
            ammo = ammo?.injectSpawnProperties(location, player),
            fuel = fuel?.injectSpawnProperties(location, player),
            gunBarrel = gunBarrel?.injectSpawnProperties(location, player),
            gunTurret = gunTurret?.injectSpawnProperties(location, player),
            health = health?.injectSpawnProperties(location, player),
            landMovementControls = landMovementControls?.injectSpawnProperties(location, player),
            model = model?.injectSpawnProperties(location, player),
            seats = seats?.injectSpawnProperties(location, player),
            seatsRaycast = seatsRaycast?.injectSpawnProperties(location, player),
            spawn = spawn?.injectSpawnProperties(location, player),
            transform = transform?.injectSpawnProperties(location, player),
        )
    }

    /**
     * During creation, inject item specific properties and generate
     * a new instance of this component. Delegates injecting property
     * effects to each individual component.
     */
    fun injectItemProperties(
        item: ItemStack,
        itemMeta: ItemMeta,
        itemData: PersistentDataContainer,
    ): VehicleElementPrototype {
        return copy(
            ammo = ammo?.injectItemProperties(item, itemMeta, itemData),
            fuel = fuel?.injectItemProperties(item, itemMeta, itemData),
            gunBarrel = gunBarrel?.injectItemProperties(item, itemMeta, itemData),
            gunTurret = gunTurret?.injectItemProperties(item, itemMeta, itemData),
            health = health?.injectItemProperties(item, itemMeta, itemData),
            landMovementControls = landMovementControls?.injectItemProperties(item, itemMeta, itemData),
            model = model?.injectItemProperties(item, itemMeta, itemData),
            seats = seats?.injectItemProperties(item, itemMeta, itemData),
            seatsRaycast = seatsRaycast?.injectItemProperties(item, itemMeta, itemData),
            spawn = spawn?.injectItemProperties(item, itemMeta, itemData),
            transform = transform?.injectItemProperties(item, itemMeta, itemData),
        )
    }
    
    /**
     * During creation, inject json specific properties and generate
     * a new instance of this component. Used to load serialized vehicle
     * state from stored json objects. Delegates injecting property
     * effects to each individual component.
     *
     * The json object passed into this function should be the one
     * storing the data for the singular element, NOT the object
     * storing the entire vehicle. See the serde file for more details
     * on schema.
     */
    fun injectJsonProperties(
        json: JsonObject,
    ): VehicleElementPrototype {
        val componentsJson = json["components"]!!.asJsonObject
        return copy(
            uuid = UUID.fromString( json["uuid"].asString ),
            ammo = ammo?.injectJsonProperties( componentsJson["ammo"]?.asJsonObject ),
            fuel = fuel?.injectJsonProperties( componentsJson["fuel"]?.asJsonObject ),
            gunBarrel = gunBarrel?.injectJsonProperties( componentsJson["gunBarrel"]?.asJsonObject ),
            gunTurret = gunTurret?.injectJsonProperties( componentsJson["gunTurret"]?.asJsonObject ),
            health = health?.injectJsonProperties( componentsJson["health"]?.asJsonObject ),
            landMovementControls = landMovementControls?.injectJsonProperties( componentsJson["landMovementControls"]?.asJsonObject ),
            model = model?.injectJsonProperties( componentsJson["model"]?.asJsonObject ),
            seats = seats?.injectJsonProperties( componentsJson["seats"]?.asJsonObject ),
            seatsRaycast = seatsRaycast?.injectJsonProperties( componentsJson["seatsRaycast"]?.asJsonObject ),
            spawn = spawn?.injectJsonProperties( componentsJson["spawn"]?.asJsonObject ),
            transform = transform?.injectJsonProperties( componentsJson["transform"]?.asJsonObject ),
        )
    }
    
    /**
     * During creation, for each component, send post creation properties,
     * for post-processing after the vehicle has been created. Such as
     * setting up entity to vehicle mappings for armor stands.
     */
    fun afterVehicleCreated(
        vehicleId: VehicleId,
        elementId: VehicleElementId,
        elementLayout: EnumSet<VehicleComponentType>,
        entityVehicleData: HashMap<UUID, EntityVehicleData>,
    ) {
        for ( c in layout ) {
            when ( c ) {
                VehicleComponentType.AMMO -> ammo?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.FUEL -> fuel?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.GUN_BARREL -> gunBarrel?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.GUN_TURRET -> gunTurret?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.HEALTH -> health?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.LAND_MOVEMENT_CONTROLS -> landMovementControls?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.MODEL -> model?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SEATS -> seats?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SEATS_RAYCAST -> seatsRaycast?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.SPAWN -> spawn?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                VehicleComponentType.TRANSFORM -> transform?.afterVehicleCreated(
                    vehicleId=vehicleId,
                    elementId=elementId,
                    elementLayout=elementLayout,
                    entityVehicleData=entityVehicleData,
                )
                null -> {}
            }
        }
    }

    companion object {
        public fun fromToml(toml: TomlTable, logger: Logger? = null, vehicleName: String): VehicleElementPrototype {
            // element built-in properties
            val name = toml.getString("name") ?: ""
            val parent = toml.getString("parent")
            
            // all possible components to be parsed
            var ammo: AmmoComponent? = null
            var fuel: FuelComponent? = null
            var gunBarrel: GunBarrelComponent? = null
            var gunTurret: GunTurretComponent? = null
            var health: HealthComponent? = null
            var landMovementControls: LandMovementControlsComponent? = null
            var model: ModelComponent? = null
            var seats: SeatsComponent? = null
            var seatsRaycast: SeatsRaycastComponent? = null
            var spawn: SpawnComponent? = null
            var transform: TransformComponent? = null

            // parse components from matching keys in toml
            val layout = EnumSet.noneOf(VehicleComponentType::class.java)
            val keys = toml.keySet()
            for ( k in keys ) {
                when ( k ) {
                    "name", "parent" -> continue
                    "ammo" -> {
                        layout.add(VehicleComponentType.AMMO)
                        ammo = AmmoComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "fuel" -> {
                        layout.add(VehicleComponentType.FUEL)
                        fuel = FuelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "gun_barrel" -> {
                        layout.add(VehicleComponentType.GUN_BARREL)
                        gunBarrel = GunBarrelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "gun_turret" -> {
                        layout.add(VehicleComponentType.GUN_TURRET)
                        gunTurret = GunTurretComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "health" -> {
                        layout.add(VehicleComponentType.HEALTH)
                        health = HealthComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "land_movement_controls" -> {
                        layout.add(VehicleComponentType.LAND_MOVEMENT_CONTROLS)
                        landMovementControls = LandMovementControlsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "model" -> {
                        layout.add(VehicleComponentType.MODEL)
                        model = ModelComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "seats" -> {
                        layout.add(VehicleComponentType.SEATS)
                        seats = SeatsComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "seats_raycast" -> {
                        layout.add(VehicleComponentType.SEATS_RAYCAST)
                        seatsRaycast = SeatsRaycastComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "spawn" -> {
                        layout.add(VehicleComponentType.SPAWN)
                        spawn = SpawnComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    "transform" -> {
                        layout.add(VehicleComponentType.TRANSFORM)
                        transform = TransformComponent.fromToml(toml.getTable(k)!!, logger)
                    }
                    else -> logger?.warning("Unknown key in vehicle element: $k")
                }
            }
            
            return VehicleElementPrototype(
                name,
                parent,
                vehicleName,
                layout,
                ammo,
                fuel,
                gunBarrel,
                gunTurret,
                health,
                landMovementControls,
                model,
                seats,
                seatsRaycast,
                spawn,
                transform,
            )
        }
    }
}